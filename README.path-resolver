
here is ideas and cases we have to cover.

You're MORE than welcome to add more cases, ideas and other things
that may help... Questions are ok too.

=head1 FIRST MILESTONE

looked deeper in the code and decided that it's better to stop on following goals:

1) For new files we can stop on "add" and "skip" actions.
* this is implemented:
** for every new node you're asked if you want to add it then parent
   dirs that don't exist are added back.
** if it's dir then you can add only dir itself, but as well you can
   add it with all its children without questions

2) For changes it's possible to use the resolver we already have.
* implemented, but without (old, base, new) resolver, just add or skip

=head2 M1 TODO

=head3 Bugs

* t/22status-conflict.t fails and there is no way to fix it without
  adjusting the way we distinguish tree conflicts vs. skips
* fix t/smerge/path-resolver/change_in_deleted_file_co.t, it
  has some issues I don't know how treat them
* eol style is not handled when we return back a file

=head3 Features

* resolver help
* l)ist action for add_directory
* dt - diff thiers action for a file change
* c)at action for add_file

=head1 SIDENOTES

* if I resolve a conflict then I do want svk to commit after all even
  if overall merge is empty. I don't want to resolve things again and
  this is not only about path resolving.
** done

=head1 CASES

=head2 new node in locally deleted dir

=head3 case

new node in dir A is added on trunk when that dir is deleted in local.
we skip such change during smerge when we should
1) allow user to return back A in local with new file
2) allow user to enter new path for the node 
    ** this must be handled during further smerges as rename, even if
    that file never existed
2.1) new path may exist already and may be it has different type
2.1.1) user may want replace node if types are diffrent
2.1.2) user may want replace and save old node what falls into recursion :(
       of resolving
2.1.3) if types match, does he mean replace, is it 3) for dirs or
       is it text merge of files?
3) allow to say that A is now B in local, even if B is not actually is
   copy of A, it shouldn't be treated as replace, but as merge of two
   streams so changes on trunk in A and B goes into the same dir in
   the local repo.

=head3 implementation notes

* open_directory should be "wait" when we'll merge everything down
  the path and then either do nothing (2 from above) or
  add dir back again (1 from above)
* not sure if there is way to do 3
** can a new merge ticket on dir B in the local help us? so we will
   have two tickets: one on root of the branch and another on dir B
   that it's been merged from trunk/A...


