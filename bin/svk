#!/usr/bin/perl -w
use strict;
require SVN::Core;
require SVN::Repos;
use SVN::XD;
use YAML qw(LoadFile DumpFile);
use Getopt::Long;
use File::Spec;
use Data::Hierarchy;

use vars qw/$xd/;
use subs qw/co up st blame ci/;

my $info;

=head1 NAME

svk - subversion keeper command line interface

=head1 SYNOPSIS


=head1 DESCRIPTION


=cut

sub init {
    if (-d "$ENV{HOME}/.svk") {
	$info = LoadFile ("$ENV{HOME}/.svk/config");
    }
    else {
	mkdir "$ENV{HOME}/.svk";
    }

    $info ||= { depotmap => {'' => "$ENV{HOME}/svn/svm" },
	        checkout => Data::Hierarchy->new(),
	      };
}

sub update_info {
    DumpFile ("$ENV{HOME}/.svk/config", $info)
}

sub find_repos {
    my ($depotpath, $open) = @_;
    my ($depot, $path) = $depotpath =~ m|^/(\w*)/(.*)/?$|;

    die "non-default depot name not supported yet" if $depot;

    my $repospath = $info->{depotmap}{$depot} or die "no such depot: $depot";

    return ($repospath, $path, $open && SVN::Repos::open ($repospath));
}

sub find_repos_from_co {
    my ($copath, $open) = @_;
    $copath = File::Spec->rel2abs ($copath);

    my ($cinfo, $coroot) = $info->{checkout}->get ($copath);
    die "$copath not a checkout path" unless %$cinfo;
    my ($repospath, $path, $repos) = find_repos ($cinfo->{depotpath}, $open);

    $copath =~ s/^$coroot//;

    return ($repospath, $path.$copath, $cinfo, $repos);
}


=head2 update / up

    svk update

=cut

sub update {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);

    my ($copath) = @ARGV;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    $copath = File::Spec->rel2abs ($copath);

    # XXX: support via reporter facility in the future

    $rev = $repos->fs->youngest_rev unless defined $rev;

    SVN::XD::do_update ($info,
			repos => $repos,
			depotpath => $cinfo->{depotpath},
			copath => $copath,
			repospath => $repospath,
			path => $path,
			startrev => $cinfo->{revision},
			rev => $rev,
		       );
    $info->{checkout}->store_recursively ($copath, {revision => $rev});
}

=head2 checkout / co

    svk checkout

=cut

sub checkout {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($depotpath, $copath) = @ARGV;


    my ($repospath, $path) = find_repos ($depotpath, 0);
    $copath = File::Spec->rel2abs ($copath ||
				   (File::Spec->splitdir($path))[-1]);
    die "don't know where to checkout" unless $copath || $path;

    die "checkout path $copath already exists" if -e $copath;

    mkdir ($copath);
    $info->{checkout}->store($copath, {depotpath => $depotpath, revision =>0});

    update ($copath, $rev)
}

=head2 diff

    svk diff

=cut

use Text::Diff ();

sub diff {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '.');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my $root = $repos->fs->revision_root ($cinfo->{revision});
    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       root => $root,
			       cb_unknown =>
			       sub {
				   print "?  $_[1]\n";
			       },
			       cb_add =>
			       sub {
				   print Text::Diff::diff (\'', $_[1]);
			       },
			       cb_changed =>
			       sub {
				   print Text::Diff::diff ($root->file_contents($_[0]), $_[1])
			       },
			      );

}

=head2 status / st

    svk status

=cut

sub status {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath);
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       root => $repos->fs->revision_root ($cinfo->{revision}),
			       cb_unknown =>
			       sub {
				   print "?  $_[1]\n";
			       },
			       cb_add =>
			       sub {
				   print "A  $_[1]\n";
			       },
			       cb_changed =>
			       sub {
				   print "M  $_[1]\n";
			       },
			      );

}

=head2 annotate / blame

    svk annotate

=cut

use Algorithm::Annotate;

sub annotate {
    local @ARGV = @_;
    my $cross = 0;
    die unless GetOptions ("x|cross"  => \$cross);
    my ($copath) = @ARGV;

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $ann = Algorithm::Annotate->new;
    my @revs;
    my $hist = $root->node_history ($path);

    while ($hist = $hist->prev($cross)) {
	my ($path, $rev) = $hist->location;
	unshift @revs, $rev;
    }

    print "Annotations for $path (".($#revs+1)." active revisions)\n";
    print '*' x 16;
    print "\n";
    my $pool = SVN::Pool->new_default;
    for (@revs) {
	$pool->clear;
	local $/;
	my $content = $fs->revision_root($_)->file_contents($path);
	$content = [split "[\n\r]", <$content>];
	$ann->add ( sprintf("%6s\t(%8s %10s):\t\t", $_,
			    $fs->revision_prop ($_, 'svn:author'),
			    substr($fs->revision_prop ($_, 'svn:date'),0,10)),
		    $content);
    }

    open my ($fh), $copath;

    $ann->add ( "\t(working copy): \t\t", [map {chomp;$_}<$fh>]);

    seek $fh, 0, 0;

    my $result = $ann->result;
    while (my $info = shift @$result) {
	print $info.<$fh>;
    }

}

=head2 add

=cut

sub add {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath);
    my ($repospath, $path, $cinfo) = find_repos_from_co ($copath, 0);

    die "no dir yet" if -d $copath;

    SVN::XD::do_add ($info,
		     copath => $copath,
		     path => $path,
		    );

    print "A  $copath\n";
}

=head2 commit / ci

    svk commit

=cut

sub commit {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath);
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    # harvest
    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       root => $repos->fs->revision_root ($cinfo->{revision}),
			       cb_unknown =>
			       sub {},
			       cb_add =>
			       sub {
				   print "A  $_[1]\n";
			       },
			       cb_changed =>
			       sub {
				   print "M  $_[1]\n";
			       },
			      );
}

*co = *checkout;
*up = *update;
*st = *status;
*blame = *annotate;
*ci = *commit;

my $defaultdepot;

die unless GetOptions ("depot=s"  => \$defaultdepot);

my $cmd = shift;

no strict 'refs';

#$xd = SVN::XD->new (%$info);

die "command not recognized" unless main->can($cmd);
init();
&$cmd(@ARGV);
update_info()

#%$info = %$xd;
