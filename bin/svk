#!/usr/bin/perl -w
use strict;
our $VERSION = '0.08';
require SVN::Core;
require SVN::Client;
require SVN::Repos;
require SVN::Fs;
use SVN::XD;
use YAML qw(LoadFile DumpFile);
use Getopt::Long qw(:config no_ignore_case);
use Cwd;
use File::Spec;
use File::Path ();
use Data::Hierarchy;
use IO::String;
use SVN::DiffEditor;
use SVN::StatusEditor;
use SVN::CommitStatusEditor;
use File::Temp qw/:mktemp/;

use vars qw/$xd $info/;
use subs qw/co up st blame ci del rm ps pe pl cp sy sm desc ver/;

my $svn_mirror;
eval 'require SVN::Mirror' and ++$svn_mirror;

my $auth = SVN::Core::auth_open
    ([SVN::Client::get_simple_provider (),
      SVN::Client::get_ssl_server_trust_file_provider (),
      SVN::Client::get_username_provider ()]);

my $target_prompt = '=== below are targets to be committed ===';

=head1 NAME

svk - a decentralized version control system

=head1 SYNOPSIS


=head1 DESCRIPTION


=cut

=head1 COMMANDS

=cut

=head2 help

Describe the usage of this program or its subcommands.

  usage: help [SUBCOMMANDS...]

=cut

use Pod::Text;

sub help {
    my $parser = new Pod::Text->new ();
    @_ = qw/help/ unless @_;
    # XXX: the order from selected is not preserved.
    $parser->select (map {"COMMANDS/.*\\b$_\\b.*"} @_);
    $parser->parse_from_file ($0);

    if ($_[0] eq 'help') {
	my $ofh = IO::String->new (\my $list);
	$parser = new Pod::Select->new ();
	$parser->select ('COMMANDS');
	$parser->parse_from_file ($0, $ofh);
	print "Available commands:\n";
	print join("\n", (sort ($list =~ m/^=head2\s(.*)$/mg)), '');
    }
}

=head2 version (ver)

Report the current version of svk

=cut


sub version {
    print "This is svk version ".$VERSION."\n";
}



=head2 depotmap

Create or edit the depot mapping configuration.

Each line contains a map entry, the format is:

 depotname: 'path/to/repos'

The depotname could be used in DEPOTPATH as

 /depotname/path/in/repos

=cut

sub depotmap {
    my $sep = '===edit the above depot map===';
    my $map = YAML::Dump ($info->{depotmap});
    my $new;
    do {
	$map = get_buffer_from_editor ('depot map', $sep, "$map\n$sep\n",
				       '/tmp/svk-depotmapXXXXX');
	$new = eval { YAML::Load ($map) };
	print "$@\n" if $@;
    } while ($@);
    print "New depot map saved.\n";
    $info->{depotmap} = $new;
    for my $path(values %{$info->{depotmap}}) {
	my $ans;
	next if -d $path;
	print "Repository $path does not exist, create? (y/n) ";
	while (<STDIN>) {
	    $ans = $1 if $_ =~ m/^([yn])/i;
	    last if $ans;
	}
	next if $ans eq 'n';
	File::Path::mkpath([$path], 0, 0711);
	SVN::Repos::create($path, undef, undef, undef,
			   {'bdb-txn-nosync' => '1',
			    'bdb-log-autoremove' => '1'});
    }
}

sub _init {
    my $svkpath = "$ENV{HOME}/.svk";

    die "Another svk might be running. remove $svkpath/lock if not"
	if -e "$svkpath/lock";

    if (-e "$svkpath/config") {
	$info = LoadFile ("$svkpath/config");
    }
    else {
	mkdir ($svkpath);
    }

    open my ($lock), ">$svkpath/lock";
    print $lock $$;
    close $lock;

    $info ||= { depotmap => {'' => "$svkpath/local" },
	        checkout => Data::Hierarchy->new(),
	      };
}

sub _update_info {
    my $svkpath = "$ENV{HOME}/.svk";
    DumpFile ("$svkpath/config", $info);
    unlink ("$svkpath/lock");
}

sub find_repos {
    my ($depotpath, $open) = @_;
    die "not depotspec" unless $depotpath;
    my ($depot, $path) = $depotpath =~ m|^/(\w*)(/.*)/?$|
	or die "not depot spec";

    my $repospath = $info->{depotmap}{$depot} or die "no such depot: $depot";

    return ($repospath, $path, $open && SVN::Repos::open ($repospath));
}

sub find_repos_from_co {
    my ($copath, $open) = @_;
    $copath = Cwd::abs_path ($copath || '');

    my ($cinfo, $coroot) = $info->{checkout}->get ($copath);
    die "$copath not a checkout path" unless %$cinfo;
    my ($repospath, $path, $repos) = find_repos ($cinfo->{depotpath}, $open);

    if ($copath eq $coroot) {
	$copath = '';
    }
    else {
	$copath =~ s|^$coroot/|/|;
    }

    return ($repospath, $path eq '/' ? $copath : $path.$copath,
	    $cinfo, $repos);
}

sub find_repos_from_co_maybe {
    my ($target, $open) = @_;
    my ($repospath, $path, $copath, $cinfo, $repos);
    unless (($repospath, $path, $repos) = eval { find_repos ($target, $open) }) {
	undef $@;
	($repospath, $path, $cinfo, $repos) = find_repos_from_co ($target, $open);
	$copath = Cwd::abs_path ($target || '');
    }
    return ($repospath, $path, $copath, $cinfo, $repos);
}

sub find_depotname {
    my ($target, $can_be_co) = @_;
    my ($cinfo);
    if ($can_be_co) {
	(undef, undef, $cinfo) = eval { find_repos_from_co ($target, 0) };
	if ($@) {
	    undef $@;
	}
	else {
	    $target = $cinfo->{depotpath};
	}
    }

    find_repos ($target, 0);
    return ($target =~ m|^/(.*?)/|);
}

=head2 update (up)

Bring changes from the repository into checkout copies.

  usage: update [PATH...]

Synchronize checkout copies to revision given by -r or to HEAD
revision by deafult.

For each updated item a line will start with a character reporting the
action taken. These characters have the following meaning:

  A  Added
  D  Deleted
  U  Updated
  C  Conflict
  G  Merged
  g  Merged without actual change

A character in the first column signifies an update to the actual
file, while updates to the file's props are shown in the second
column.

  options:
    -r [--revision]:      revision

=cut

sub update {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);

    push @ARGV, '' if $#ARGV < 0;
    for my $copath (@ARGV) {
	my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
	$copath = Cwd::abs_path ($copath);

	$rev = $repos->fs->youngest_rev unless defined $rev;

	SVN::XD::do_update ($info,
			    repos => $repos,
			    depotpath => $cinfo->{depotpath},
			    copath => $copath,
			    repospath => $repospath,
			    path => $path,
			    rev => $rev,
			   );
    }
}

=head2 checkout (co)

Check out a copy from depot.

  usage: checkout DEPOTPATH [PATH]

Note: If PATH is omitted, the basename of the DEPOTPATH will be used
as the destination.

  options:
    -r [--revision]:      revision

=cut

sub checkout {
    local @ARGV = @_;
    my $rev = 0;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($depotpath, $copath) = @ARGV;

    my ($repospath, $path) = find_repos ($depotpath, 0);
    die "don't know where to checkout" unless $copath || $path ne '/';
    # FIXME: work on path inside depot should always use UNIX File::Spec
    $copath = Cwd::abs_path ($copath ||
				   (File::Spec->splitdir($path))[-1]);

    die "checkout path $copath already exists" if -e $copath;

    if (my ($entry, @where) = $info->{checkout}->get ($copath)) {
	die "overlapping checkout path not supported yet ($where[-1])"
	    if exists $entry->{depotpath} && $where[-1] ne $copath;
    }

    mkdir ($copath);
    $info->{checkout}->store_recursively ($copath,
					  {depotpath => $depotpath,
					   schedule => undef,
					   newprop => undef,
					   deleted => undef,
					   conflict => undef,
					   revision =>0});

    update ($copath);
}

=head2 switch

Bring current checkout to another branch.

  usage: switch DEPOTPATH [PATH]

=cut

sub switch {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($target, $copath) = @_;
    $copath ||= '';
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my ($trepospath, $tpath) = find_repos ($target, 0);

    $copath = Cwd::abs_path ($copath);

    die "different depot" unless $repospath eq $trepospath;

    my ($entry, @where) = $info->{checkout}->get ($copath);

    die "can only switch checkout root" unless $where[-1] eq $copath;

    $rev = $repos->fs->youngest_rev unless defined $rev;

    SVN::XD::do_update ($info,
			repos => $repos,
			depotpath => $cinfo->{depotpath},
			copath => $copath,
			repospath => $repospath,
			path => $path,
			target_path => $tpath,
			rev => $rev,
		       );

    $info->{checkout}->store ($copath, {depotpath => $target});
}

=head2 info

Display information about a file or directory.

  usage: info [PATH...]

=cut

sub info {
    local @ARGV = @_;
    my ($copath) = @_;
    $copath = Cwd::abs_path ($copath || '');
    my $depotpath = $info->{checkout}->get ($copath)->{depotpath}
	or die "$copath not a checkout path";
    my ($depot, undef) = $depotpath =~ m|^/(\w*)(/.*)/?$|;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $rev = $cinfo->{revision};
    print "Depot Path: /$depot$path\n";
    print "Revision: $rev\n";
    print "Last Changed Rev: ".
	$repos->fs->revision_root ($rev)->node_created_rev ($path)."\n";
}

=head2 diff

Display the differences between two paths.

  options:
    -r [--revision]:      revision spec from:to
    -v [--verbose]:       print changed path in changes

=cut

sub diff {
    local @ARGV = @_;
    my $verbose = 0;
    my $revspec;

    die unless GetOptions ("v|verbose"	=> \$verbose,
			   "r|revision=s" => \$revspec);

    my ($tgt, $tgt2) = @ARGV;

    my ($repospath, $path, $cinfo, $repos);

    if (($revspec && (my ($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/))
	|| $tgt2) {
	my ($repospath2, $path2);
	($repospath, $path, $repos) = eval { find_repos ($tgt, 1) };
	if ($@) {
	    ($repospath, $path, undef, $repos) =
		find_repos_from_co (Cwd::abs_path ($tgt || ''), 1);
	    undef $@;
	    die "Invalid arguments" if $tgt2;
	}
	elsif ($tgt2) {
	    ($repospath2, $path2) = find_repos ($tgt2, 0);
	    die "different repository"
		if $repospath ne $repospath2;
	}
	my $fs = $repos->fs;

	$path2 ||= $path;
	$fromrev ||= $revspec || $fs->youngest_rev;
	$torev ||= $revspec || $fs->youngest_rev;
	my $baseroot = $fs->revision_root ($fromrev);
	my $newroot = $fs->revision_root ($torev);

	if ($baseroot->check_path ($path) == $SVN::Node::file) {
	    SVN::DiffEditor::output_diff ($path, "revision $fromrev",
					  "revision $torev",
					  $path, $path2,
					  $baseroot->file_contents ($path),
					  $newroot->file_contents ($path2));
	    return;
	}

	my $editor = SVN::DiffEditor->new
	    ( cb_basecontent => sub { my ($rpath) = @_;
				      my $base = $baseroot->file_contents ("$path/$rpath");
				      return $base;
				  },
	      cb_baseprop => sub { my ($rpath, $pname) = @_;
				   return $baseroot->node_prop ("$path/$rpath", $pname);
			       },
	      llabel => "revision $fromrev",
	      rlabel => "revision $torev",
	      lpath  => $path,
	      rpath  => $path2,
	    );

	SVN::Repos::dir_delta ($baseroot, $path, '',
			       $newroot, $path2,
			       $editor, undef,
			       1, 1, 0, 1);

    }
    else {
	die "revision should be N:M or N"
	    if $revspec && $revspec !~ /^\d+$/;
	my $copath = Cwd::abs_path ($tgt || '');
	($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

	my $fs = $repos->fs;
	my ($txn, $xdroot) = SVN::XD::create_xd_root ($info,
						      path => $path,
						      repos => $repos,
						      copath => $copath);

	my $baseroot = $revspec ? $fs->revision_root ($revspec) : $xdroot;

	if ($baseroot->check_path ($path) == $SVN::Node::file) {
	    SVN::DiffEditor::output_diff ($path,
					  'revision '.
					  ($revspec || $info->{checkout}->get
					   ($copath)->{revision}),
					  "local",
					  $path, $path,
					  $baseroot->file_contents ($path),
					  SVN::XD::get_fh ($xdroot, '<', $path, $copath));
	    return;
	}

	my $editor = SVN::DiffEditor->new
	    ( cb_basecontent =>
	      sub { my ($rpath) = @_;
		    $baseroot->file_contents ("$path/$rpath");
		},
	      cb_baseprop =>
	      sub { my ($rpath, $pname) = @_;
		    return $baseroot->node_prop ("$path/$rpath", $pname);
	      },
	      cb_llabel =>
	      sub { my ($rpath) = @_;
		    $revspec ||
		    'revision '.
			$info->{checkout}->get ("$copath/$rpath")->{revision};
	      },
	      rlabel => "local",
	    );

	undef $@;

	SVN::XD::checkout_delta ($info,
				 repos => $repos,
				 copath => $copath,
				 path => $path,
				 baseroot => $baseroot,
				 xdroot => $xdroot,
				 strict_add => 1,
				 editor => $editor,
				);
	$txn->abort if $txn;
    }
}

=head2 status (st)

Print the status of working copy files and directories.

=cut

sub status {
    local @ARGV = @_;
    my ($report, $copath, @targets);
    @ARGV = ('') if $#ARGV == -1;
    ($report, $copath, @targets )= condense (@ARGV);
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my ($txn, $xdroot) = SVN::XD::create_xd_root ($info,
						  path => $path,
						  repos => $repos,
						  copath => $copath);

    SVN::XD::checkout_delta ($info,
			     repos => $repos,
			     copath => $copath,
			     targets => @targets ? \@targets : undef,
			     path => $path,
			     baseroot => $xdroot,
			     xdroot => $xdroot,
			     delete_verbose => 1,
			     strict_add => 1,
			     editor => SVN::StatusEditor->new
			     (copath => $copath, dpath => $path,
			      rpath => $report),
			     cb_conflict => \&SVN::StatusEditor::conflict,
			     cb_unknown => sub {$_[1] =~ s|^$copath/|$report|;
						print "?  $_[1]\n"}
			    );

    $txn->abort if $txn;
}

=head2 resolved

Mark checkout files or directories as resolved from conflict state.

  usage: resolved PATH...

  options:
    -R [--recursive]:       descend recursively

=cut

sub resolved {
    local @ARGV = @_;
    my $rec = 0;
    die unless GetOptions ("R|recursive"	=> \$rec);

    for my $copath (@ARGV) {
	$copath = Cwd::abs_path ($copath || '');
	my ($repospath, $path, undef, $repos) =
	    find_repos_from_co ($copath, 1);

	SVN::XD::do_resolved ($info,
			      repos => $repos,
			      copath => $copath,
			      path => $path,
			      recursive => $rec,
			     );
    }
}

=head2 annotate (blame)

Output the content of specified files or DEPOTPATHs with revision and
author information in-line.

  usage: 1. annotate PATH
         2. annotate DEPOTPATH

  options:
    -x [--cross]:           cross copied node

=cut

use Algorithm::Annotate;

sub annotate {
    local @ARGV = @_;
    my $cross = 0;
    die unless GetOptions ("x|cross"  => \$cross);
    my ($target) = @ARGV;
    my ($repospath, $path, $copath, undef, $repos) = find_repos_from_co_maybe ($target, 1);

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $ann = Algorithm::Annotate->new;
    my @revs;

    my $pool = SVN::Pool->new_default_sub;
    my $hist = $root->node_history ($path);
    while ($hist = $hist->prev($cross)) {
	$pool->clear;
	my ($path, $rev) = $hist->location;
	unshift @revs, $rev;
    }

    print "Annotations for $path (".($#revs+1)." active revisions)\n";
    print '*' x 16;
    print "\n";
    for (@revs) {
	$pool->clear;
	local $/;
	my $content = $fs->revision_root($_)->file_contents($path);
	$content = [split "[\n\r]", <$content>];
	$ann->add ( sprintf("%6s\t(%8s %10s):\t\t", $_,
			    $fs->revision_prop ($_, 'svn:author') || '',
			    substr($fs->revision_prop ($_, 'svn:date'),0,10)),
		    $content);
    }

    my $final;
    if ($copath) {
	open $final, $copath;
	$ann->add ( "\t(working copy): \t\t", [map {chomp;$_}<$final>]);
	seek $final, 0, 0;
    }
    else {
	$final = $fs->revision_root($revs[-1])->file_contents($path);
    }
    my $result = $ann->result;
    while (my $info = shift @$result) {
	print $info.<$final>;
    }

}

=head2 add

Put files and directories under version control, scheduling
them for addition to repository.  They will be added in next commit.

  options:
    -N [--non-recursive]:   operate on single directory only

=cut

*get_anchor = *SVN::XD::get_anchor;

sub condense {
    my @targets = map {Cwd::abs_path ($_ || '')} @_;
    my ($anchor, $report);
    $report = $_[0];
    for (@targets) {
	if (!$anchor) {
	    $anchor = $_;
	    $report = $_[0]
	}
	my $schedule = $info->{checkout}->get_single ($anchor)->{schedule} || '';
	if ($anchor ne $_ || -f $anchor ||
	    $schedule eq 'add' || $schedule eq 'delete') {
	    while ($anchor.'/' ne substr ($_, 0, length($anchor)+1)) {
		($anchor, $report) = get_anchor (0, $anchor, $report);
	    }
	}
    }
    $report .= '/' unless $report eq '' || substr($report, -1, 1) eq '/';
    return ($report, $anchor,
	    map {s|^$anchor/||;$_} grep {$_ ne $anchor} @targets);
}

sub add {
    local @ARGV = @_;
    my $nrec = 0;
    die unless GetOptions ("N|non-recursive"	=> \$nrec);

    my ($copath, @targets);
    die unless @ARGV;
    (undef, $copath, @targets) = condense (@ARGV);

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_add ($info,
		     repos => $repos,
		     copath => $copath,
		     targets => @targets ? \@targets : undef,
		     path => $path,
		     recursive => !$nrec,
		    );
}

=head2 mkdir

Create a versioned directory.

=cut

sub mkdir {
    local @ARGV = @_;
    my ($copath, @targets);
    die unless @ARGV;
    (undef, $copath, @targets) = condense (@ARGV);
}

=head2 delete (del, rm)

Remove files and directories from version control.

=cut

sub delete {
    local @ARGV = @_;
    my ($copath, @targets);
    die unless @ARGV;
    (undef, $copath, @targets) = condense (@ARGV);

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_delete ($info,
			repos => $repos,
			copath => $copath,
			targets => @targets ? \@targets : undef,
			path => $path,
		       );
}

=head2 proplist (pl)

List all properties on files, or dirs.

  usage: proplist PATH...

  options:
    -r [--revision]:        revision
    -v [--verbose]:         print extra information

=cut

sub proplist {
    local @ARGV = @_;
    my $verbose = 0;
    my $rev;

    die unless GetOptions ("v|verbose"	=> \$verbose,
			   "r|revision=i" => \$rev);

    push @ARGV, '' if $#ARGV < 0;
    for my $target (@ARGV) {
	my ($repospath, $path, $copath, undef, $repos) = find_repos_from_co_maybe ($target, 1);
	$rev ||= $repos->fs->youngest_rev unless $copath;

	my $props = SVN::XD::do_proplist ($info,
					  repos => $repos,
					  copath => $copath,
					  path => $path,
					  rev => $rev,
					 );
	return unless %$props;
	print "Properties on $copath:\n";
	while (my ($key, $value) = each (%$props)) {
	    print "$key: $value\n";
	}
    }
}

=head2 propedit (pe)

Edit property PROPNAME with $EDITOR on targets.

usage: propedit PROPNAME PATH

=cut

sub propedit {
    my ($pname, $copath) = @_;
    $copath = Cwd::abs_path ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my $pvalue = SVN::XD::do_proplist ($info,
				       repos => $repos,
				       copath => $copath,
				       path => $path,
				      )->{$pname};


    $pvalue = get_buffer_from_editor ("property $pname", undef, $pvalue,
				      '/tmp/svk-propXXXXX');

    SVN::XD::do_propset ($info,
			 propname => $pname,
			 propvalue => $pvalue,
			 repos => $repos,
			 copath => $copath,
			 path => $path,
			);

}

=head2 propset (ps)

Set PROPNAME to PROPVAL on files, or dirs.

  usage: propset PROPNAME PROPVAL PATH

=cut

sub propset {
    local @ARGV = @_;
    my ($message);
    die unless GetOptions ("m|message=s"  => \$message,
			  );

    my ($pname, $pvalue, $target) = @ARGV;
    my ($repospath, $path, $copath, undef, $repos) = find_repos_from_co_maybe ($target, 1);

    if ($copath) {
	SVN::XD::do_propset ($info,
			     propname => $pname,
			     propvalue => $pvalue,
			     repos => $repos,
			     copath => $copath,
			     path => $path,
			    );
    }
    else {
	$message = get_buffer_from_editor ('log message', $target_prompt,
					   "\n$target_prompt\n",
					   "/tmp/svk-commitXXXXX")
	    unless defined $message;

	SVN::XD::do_propset_direct ($info,
				    author => $ENV{USER},
				    repospath => $repospath,
				    propname => $pname,
				    propvalue => $pvalue,
				    repos => $repos,
				    path => $path,
				    message => $message,
				   );
    }
}

=head2 revert

Restore pristine working copy file (undo most local edits).

  usage: revert PATH...

  options:
    -R [--recursive]:       descend recursively

=cut

sub revert {
    local @ARGV = @_;
    my $rec = 0;
    die unless GetOptions ("R|recursive"	=> \$rec);

    my (undef, $copath, @targets) = condense (@ARGV);

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_revert ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
			targets => @targets ? \@targets : undef,
			recursive => $rec,
		       );
}

=head2 log

Show the log messages for revisions.

  usage: 1. log DEPOTPATH
         2. log PATH

  options:
    -r [--revision]:        revision spec from:to
    -l [--limit]:           limit the number of revisions displayed
    -x [--cross]:           cross copied node
    -v [--verbose]:         print changed path in changes

=cut

sub log_remote_rev {
    my ($repos, $rev) = @_;
    my $revprops = $repos->fs->revision_proplist ($rev);

    my ($rrev) = map {$revprops->{$_}} grep {m/^svm:headrev:/} keys %$revprops;

    return $rrev ? " (orig r$rrev)" : '';
}

sub log {
    local @ARGV = @_;
    my ($limit, $revspec, $cross, $verbose) = (undef, undef, 0, 0);
    die unless GetOptions ("l|limit=i"		=> \$limit,
			   "r|revision=s"	=> \$revspec,
			   "x|cross"		=> \$cross,
			   "v|verbose"		=> \$verbose);

    my ($tgt) = @ARGV;
    my ($repospath, $path, $copath, undef, $repos) = find_repos_from_co_maybe ($tgt, 1);

    my $fs = $repos->fs;
    my ($fromrev, $torev);
    ($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	or $fromrev = $torev = $revspec
	    if $revspec;
    $fromrev ||= $fs->youngest_rev;
    $torev ||= 0;

    if ($limit) {
	my $pool = SVN::Pool->new_default;
	my $hist = $fs->revision_root ($fromrev)->node_history ($path);
	while (($hist = $hist->prev($cross)) && $limit--) {
	    $pool->clear;
	    $torev = ($hist->location)[1];
	}
    }

    do_log ($repos, $path, $fromrev, $torev, $verbose, $cross, 1);
}

sub do_log {
    my ($repos, $path, $fromrev, $torev, $verbose, $cross, $remote, $output)
	= @_;
    $output ||= \*STDOUT;
    print $output ('-' x 70);
    print $output "\n";
    $repos->get_logs ([$path], $fromrev, $torev, $verbose, !$cross,
		     sub { my ($paths, $rev, $author, $date, $message) = @_;
			   no warnings 'uninitialized';
			   print $output "r$rev".
			       ($remote ? log_remote_rev($repos, $rev): '').
				   ":  $author | $date\n";
			   if ($paths) {
			       print $output "Changed paths:\n";
			       for (sort keys %$paths) {
				   my $entry = $paths->{$_};
				   print $output
				       '  '.$entry->action." $_".
					   ($entry->copyfrom_path ?
					    " (from ".$entry->copyfrom_path.
					    ':'.$entry->copyfrom_rev.')' : ''
					   ).
					   "\n";
			       }
			   }
			   print $output "\n$message\n".('-' x 70). "\n";
		       });

}

=head2 describe (desc)

Describe a change.

  usage: describe [REVISION]

=cut

sub describe {
    local @ARGV = @_;
    my ($chg, $target) = @ARGV;
    my ($depot) = find_depotname ($target || '//', 1);

    &log ('-r', $chg, "/$depot/");
    &diff ('-r', ($chg-1).":$chg", "/$depot/");
}

=head2 commit (ci)

Commit changes to depot.

  usage: commit [PATH...]

  options:
    --m [--message] ARG:    specify commit message ARG
    --force:                force validity of log message source

=cut


sub get_buffer_from_editor {
    my ($what, $sep, $content, $file) = @_;
    my $fh;
    if (defined $content) {
	($fh, $file) = mkstemps ($file, '.tmp');
	print $fh $content;
	close $file;
    }

    while (1) {
	my $mtime = (stat($file))[9];
	my $ans;
	my $editor =	defined($ENV{SVN_EDITOR}) ? $ENV{SVN_EDITOR}
	   		: defined($ENV{EDITOR}) ? $ENV{EDITOR}
			: "vi"; # fall back to something
	print "waiting for editor...\n";
	system ("$editor $file");
	last if (stat($file))[9] > $mtime;
	do {
	    print "$what not modified: a)bort, e)dit, c)ommit?\n";
	    $ans = <STDIN>;
	    chomp $ans;
	    last if $ans eq 'c';
	    die "Aborted" if $ans eq 'a';
	}
	while ($ans !~ m/^[aec]/);
    }

    open $fh, $file;
    local $/;
    my @ret = defined $sep ? split ("\n$sep\n", <$fh>, 2) : (<$fh>);
    close $fh;
    unlink $file;
    return wantarray ? @ret : $ret[0];
}

sub path_is_mirrored {
    my ($repos, $path) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    my $rev = ($root->node_history ($path)->prev (0)->location)[1];

    return (grep {m/^svm:headrev:/} keys %{$fs->revision_proplist ($rev)});
}

sub commit {
    local @ARGV = @_;
    my ($message, $force, $check_only, $sign);
    die unless GetOptions ("m|message=s"  => \$message,
			   "C|check-only" => \$check_only,
			   "s|sign"	  => \$sign,
			   "force",	  => \$force,
			  );

    my ($copath, @targets);
    @ARGV = ('') if $#ARGV == -1;
    (undef, $copath, @targets )= condense (@ARGV);

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    print "Commit into mirrored path, merge back directly\n"
	if path_is_mirrored ($repos, $path);

    my ($txn, $xdroot) = SVN::XD::create_xd_root ($info,
						  path => $path,
						  repos => $repos,
						  copath => $copath);


    my ($fh, $file);

    unless (defined $message) {
	($fh, $file) = mkstemps("svk-commitXXXXX", '.tmp');
    }

    print $fh "\n$target_prompt\n" if $fh;

    my $targets = [];
    SVN::XD::checkout_delta ($info,
			     repos => $repos,
			     copath => $copath,
			     targets => @targets ? \@targets : undef,
			     path => $path,
			     baseroot => $xdroot,
			     xdroot => $xdroot,
			     delete_verbose => 1,
			     absent_ignore => 1,
			     strict_add => 1,
			     editor => SVN::CommitStatusEditor->new
			     (copath => $copath, dpath => $path,
			      targets => $targets, fh => $fh),
			     cb_conflict => \&SVN::StatusEditor::conflict,
			    );

    $txn->abort if $txn;

    if (grep {$_->[0] eq 'C'} @$targets) {
	if ($fh) {
	    close $fh;
	    unlink $fh;
	}
	print "Conflicts detected. Use svk resolved after resolving the conflicts.\n";
	return;
    }

    die "no targets to commit" if $#{$targets} < 0;

    if ($fh) {
	close $fh;
	$message =
	    get_buffer_from_editor ('log message', $target_prompt,
				    undef, $file);
    }

    # if $copath itself is a file or is in the targets,
    # should get the anchor instead, tweak copath for the s// in XD.pm

    $targets = [sort {$a->[1] cmp $b->[1]} @$targets];

    my ($editor, %cb) = get_editor ( repos => $repos,
				     repospath => $repospath,
				     path => $path,
				     check_only => $check_only,
				     sign => $sign,
				     message => $message,
				   );
    SVN::XD::do_commit ($info,
			author => $ENV{USER},
			message => $message,
			repos => $repos,
			repospath => $repospath,
			copath => $copath,
			path => $path,
			baserev => $cinfo->{revision},
			targets => $targets,
			# somehow pass the commit callback out from the editor
			# to sync and really bumb XD revisions
			editor => $editor,
			%cb );
}

=head2 copy (cp)

Duplicate something in working copy or repos, remembering history.

  usage: copy DEPOTPATH1 DEPOTPATH2

  options:
    -r [--revision]:        revision
    -m [--message]:         commit message

=cut

sub copy {
    local @ARGV = @_;
    my $message;
    my $rev;
    die unless GetOptions ("m|message=s"  => \$message,
			   "r|revision=i" => \$rev);
    my ($fh, $file);

    my ($src, $dst) = @ARGV;
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $editor, $copath);
    unless (($drepospath, $dpath) = eval { find_repos ($dst, 0) }) {
	die "copy doesn't work on checkout yet";
    }

    die "different repos?" if $repospath ne $drepospath;

    $message = get_buffer_from_editor ('log message', $target_prompt,
				       "\n$target_prompt\n",
				       "/tmp/svk-commitXXXXX")
	unless defined $message;

    SVN::XD::do_copy_direct ($info,
			     author => $ENV{USER},
			     repospath => $repospath,
			     repos => $repos,
			     path => $path,
			     dpath => $dpath,
			     message => $message,
			     rev => $rev || $repos->fs->youngest_rev,
			    );
}

=head2 merge

Apply the differences between two sources to a checkout copy or a
depotpath. Use -a to automatically calculate the revisions to merge 

  usage: 1. merge -r N:M DEPOTPATH [PATH]
         2. merge -r N:M DEPOTPATH1 DEPOTPATH2

  options:
    -r [--revision]:        revision
    -m message:             commit message
    -C [--check-only]:      don't perform actual writes
    -a [--auto]:            automatically find merge points
    -l [--log]:             brings the logs of merged revs to the message buffer
    --no-ticket:            don't associate the ticket tracking merge history

=cut

# when is the last merge from src to dst?
sub find_merge_history {
    my ($repos, $src, $dst) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my ($m, $uuid);
    if ($svn_mirror) {
	$m = eval 'SVN::Mirror::is_mirrored ($repos, $src)';
    }

    if ($m) {
	$uuid = $root->node_prop ($src, 'svm:uuid');
	$src = $m->{source};
	$src =~ s/^$m->{source_root}//;
    }

    $uuid ||= $repos->fs->get_uuid ();

    if (my $minfo = $root->node_prop ($dst, 'svk:merge')) {
	$minfo = { map {my ($uuid, $path, $rev) = split ':', $_;
			("$uuid:$path" => $rev);
		    } split ("\n", $minfo) };
	# resolve the rev to local rev if it's svm'ed
	if (my $r = $minfo->{join (':', $uuid, $src)}) {
	    $r = $m->find_local_rev ($r)
		if $m;
	    return $r;
	}
    }
}

sub find_merge_base {
    my ($repos, $src, $dst) = @_;
    my $srcinfo = find_merge_sources ($repos, $src);
    my $dstinfo = find_merge_sources ($repos, $dst);
    my ($basepath, $baserev);

    for (grep {exists $srcinfo->{$_} && exists $dstinfo->{$_}} (keys %{{%$srcinfo,%$dstinfo}})) {
	my ($path) = m/:(.*)$/;
	my $rev = $srcinfo->{$_} < $dstinfo->{$_} ? $srcinfo->{$_} : $dstinfo->{$_};
	# XXX: shuold compare revprop svn:date instead, for old dead branch being newly synced back
	if (!$basepath || $rev > $baserev) {
	    ($basepath, $baserev) = ($path, $rev);
	}
    }
    return ($basepath, $baserev);
    warn "merge base $basepath, $baserev";
}

sub find_merge_sources {
    my ($repos, $path, $verbatim, $noself) = @_;
    my $pool = SVN::Pool->new_default;

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $minfo = $root->node_prop ($path, 'svk:merge');
    my $myuuid = $fs->get_uuid ();
    if ($minfo) {
	$minfo = { map {my ($uuid, $path, $rev) = split ':', $_;
			my $m;
			($verbatim || ($uuid eq $myuuid)) ? ("$uuid:$path" => $rev) :
			    ($svn_mirror && ($m = SVN::Mirror::has_local ($repos, "$uuid:$path"))) ?
				("$myuuid:$m->{target_path}" => $m->find_local_rev ($rev)) : ()
			    } split ("\n", $minfo) };
    }
    if ($verbatim) {
	my ($uuid, $path, $rev) = resolve_svm_source ($repos, $path);
	$minfo->{join(':', $uuid, $path)} = $rev
	    unless $noself;
	return $minfo;
    }
    else {
	$minfo->{join(':', $myuuid, $path)} = $fs->youngest_rev
	    unless $noself;
    }

    # XXX: follow the copy history provided by svm too
    my $spool = SVN::Pool->new_default ($pool);
    my $hist = $root->node_history ($path);
    while ($hist = $hist->prev (1)) {
	$spool->clear;
	my ($hpath, $rev) = $hist->location ();
	if ($hpath ne $path) {
	    my $source = join(':', $myuuid, $hpath);
	    $minfo->{$source} = $rev
		unless $minfo->{$source} && $minfo->{$source} > $rev;
	    last;
	}
    }

    return $minfo;
}

sub resolve_svm_source {
    my ($repos, $path) = @_;
    my ($uuid, $rev, $m);
    my $mirrored;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    if ($svn_mirror) {
	$m = eval 'SVN::Mirror::is_mirrored ($repos, $path)';
    }

    if ($m) {
	$uuid = $root->node_prop ($path, 'svm:uuid');
	$path = $m->{source};
	$path =~ s/^$m->{source_root}//;
	$rev = $m->{fromrev};
    }
    else {
	($rev, $uuid) = ($fs->youngest_rev, $fs->get_uuid);
    }

    return ($uuid, $path, $rev);
}

sub get_new_ticket {
    my ($repos, $src, $dst) = @_;

    my $srcinfo = find_merge_sources ($repos, $src, 1);
    my $dstinfo = find_merge_sources ($repos, $dst, 1);
    my ($uuid, $newinfo);

    # bring merge history up to date as from source
    ($uuid, $dst) = resolve_svm_source ($repos, $dst);

    for (keys %{{%$srcinfo,%$dstinfo}}) {
	next if $_ eq "$uuid:$dst";
	no warnings 'uninitialized';
	$newinfo->{$_} = $srcinfo->{$_} > $dstinfo->{$_} ? $srcinfo->{$_} : $dstinfo->{$_};
	print "new merge ticket: $_:$newinfo->{$_}\n"
	    if !$dstinfo->{$_} || $newinfo->{$_} > $dstinfo->{$_};
    }

    return join ("\n", map {"$_:$newinfo->{$_}"} sort keys %$newinfo);
}

sub log_for_merge {
    my $buf = IO::String->new (\my $tmp);
    do_log (@_, 0, 0, 0, $buf);
    return $tmp;
}

# XXX: finish me
# given a pair of A,B-C,D-E,
# output minimum pairs of revisin pairs.
sub parse_chgspec {
    my ($repos, $chgspec, $path) = @_;

    my @chgs = split ',', $chgspec;
    for (@chgs) {
	my ($fromrev, $torev);
	if (($fromrev, $torev) = $chgspec =~ m/^(\d+):(\d+)$/) {
	    --$fromrev;
	}
	elsif (($torev) = $chgspec =~ m/^(\d+)$/) {
	    $fromrev = $torev - 1;
	}
	else {
	    die "chgspec not recognized";
	}
    }
}

# Return the editor according to copath, path, and is_mirror (path)
# It will be XD::Editor, repos_commit_editor, or svn::mirror merge back editor.
sub get_editor {
    my (%arg) = @_;
    my ($callback, $editor, %cb);

    if ($arg{copath}) {
	# XXX: really need txn auto cleanup!
	my ($txn, $xdroot) = SVN::XD::create_xd_root ($info, %arg);

	($editor, %cb) = SVN::XD::get_editor ($info, %arg,
					       oldroot => $xdroot,
					       newroot => $xdroot,
					       anchor => $arg{path},
					       target => '',
					       check_only => $arg{check_only});
	return ($editor, %cb, txn => $txn);
    }

    my ($base_rev, $m);
    if ($svn_mirror && ($m = SVN::Mirror::is_mirrored ($arg{repos}, $arg{path}))) {
	print "Merge back to SVN::Mirror source $m->{source}.\n";
	if ($arg{check_only}) {
	    print "Check against mirrored directory locally.\n";
	}
	else {
	    $m->{auth} = $auth;
	    ($base_rev, $editor) = $m->get_merge_back_editor
		($arg{message},
		 sub { print "Merge back committed as revision $_[0].\n";
		       my $rev = shift;
		       # XXX: some failsafe handler
		       $m->run ($rev);
		       &{$callback} ($m->find_local_rev ($rev), @_)
			   if $callback }
		);
	    $base_rev = $m->{fromrev};
	}
    }

    $editor ||= SVN::Delta::Editor->new
	( SVN::Repos::get_commit_editor
	  ( $arg{repos}, "file://$arg{repospath}",
	    $arg{path}, $ENV{USER}, $arg{message},
	    sub { &{$callback} (@_) if $callback}
	  ));
    $base_rev ||= $arg{repos}->fs->youngest_rev;

    $editor = SVN::XD::CheckEditor->new ($editor)
	if $arg{check_only};

    my $fs = $arg{repos}->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    %cb = ( cb_exist => $arg{cb_exist} ||
	    sub { my $path = $arg{path}.'/'.shift;
		  $root->check_path ($path) != $SVN::Node::none;
	      },
	    cb_rev => sub { $base_rev; },
	    cb_conflict => sub { die "conflict $arg{path}/$_[0]"
				     unless $arg{check_only};
				 $editor->{conflicts}++;
			     },
	    cb_localmod => $arg{cb_localmod} ||
	    sub { my ($path, $checksum, $pool) = @_;
		  $path = "$arg{path}/$path";
		  my $md5 = $root->file_md5_checksum ($path, $pool);
		  return if $md5 eq $checksum;
		  return [$root->file_contents ($path, $pool),
			  undef, $md5];
	      },
	  );


    return ($editor, %cb, mirror => $m, callback => \$callback);


=for comment

	    if ($sign && !$check_only) {
		my $digest = IO::String->new;
		$cb_closed = sub {
		    print $digest join(' ', 'MD5', $_[1], $_[0])."\n";
		};
		my $old_cb_merged = $cb_merged;
		$cb_merged = sub { my ($editor, $baton, $pool) = @_;
				   my $sig =_sign_gpg ('/tmp/svk-sign',
						       ${$digest->string_ref});
				   $editor->change_dir_prop
				       ($baton, 'svk:signature', $sig);
				   &{$old_cb_merged} (@_) };
	    }

=cut

}

sub merge {
    local @ARGV = @_;
    my ($check_only, $message, $auto, $sign, $log, $no_ticket, $revspec);
    die unless GetOptions ("C|check-only"	=> \$check_only,
			   "m|message=s"	=> \$message,
			   "a|auto"		=> \$auto,
			   "s|sign"		=> \$sign,
			   "l|log"		=> \$log,
			   "no-ticket"		=> \$no_ticket,
			   "r|revision=s"	=> \$revspec);

    my ($src, $dst) = @ARGV;
    my ($fromrev, $torev, $cb_merged, $cb_closed);
    unless ($auto) {
	die "revision required" unless $revspec;
	($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	    or die "revision must be N:M";
    }
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $copath) = find_repos_from_co_maybe ($dst, 0);
    my $dest_repos = 1 unless defined $copath;

    die "different repos?" unless $repospath eq $drepospath;

    my $base_path = $path;
    if ($auto) {
	($base_path, $fromrev, $torev) =
	    (find_merge_base ($repos, $path, $dpath), $repos->fs->youngest_rev);
	print "auto merge ($fromrev, $torev) $path -> $dpath (base $base_path)\n";
	$cb_merged = sub { my ($editor, $baton, $pool) = @_;
			   $editor->change_dir_prop
			       ($baton, 'svk:merge',
				get_new_ticket ($repos, $path, $dpath));
		       } unless $no_ticket;
    }

    unless (!$dest_repos || defined $message || $check_only) {
	$message = get_buffer_from_editor
	    ('log message', $target_prompt,
	     ($log ?
	      log_for_merge ($repos, $path, $fromrev+1, $torev) : '').
	     "\n$target_prompt\n", "svk-commitXXXXX");
    }

    # editor for the target
    my ($storage, %cb) = get_editor ( repos => $repos,
				      repospath => $repospath,
				      path => $dpath,
				      copath => $copath,
				      check_only => $check_only,
				      message => $message,
				    );

    my $fs = $repos->fs;
    my $editor = SVN::MergeEditor->new
	( anchor => $path,
	  base_anchor => $base_path,
	  base_root => $fs->revision_root ($fromrev),
	  target => '',
	  send_fulltext => $cb{mirror} ? 0 : 1,
	  cb_merged => $cb_merged,
	  storage => $storage,
	  %cb,
	);

    SVN::Repos::dir_delta ($fs->revision_root ($fromrev),
			   $base_path, '',
			   $fs->revision_root ($torev), $path,
			   $editor, undef,
			   1, 1, 0, 1);

    # cleanup txn
    $cb{txn}->abort if $cb{txn};

}

sub _sign_gpg {
    my ($sigfile, $plaintext) = @_;

    die "Could not write to $sigfile"
	if -e $sigfile and (-d $sigfile or not -w $sigfile);

    local *D;
    open D, "| gpg --clearsign > $sigfile.tmp" or die "Could not call gpg: $!";
    print D $plaintext;
    close D;

    (-e "$sigfile.tmp" and -s "$sigfile.tmp") or do {
	unlink "$sigfile.tmp";
	die "Cannot find $sigfile.tmp, signing aborted.\n";
    };

    open D, "$sigfile.tmp" or die "Cannot open $sigfile.tmp: $!";
    undef $/;
    my $buf = <D>;
    unlink("$sigfile.tmp");
    return $buf;
}


=head2 smerge (sm)

Alias to merge -a.

=cut

sub smerge {
    merge ('-a', @_);
}

=head2 cmerge

Cherry picking. This will eventually be integrated with smerge.

=cut

use SVN::CombineEditor;

sub cmerge {
    local @ARGV = @_;
    my ($check_only, $message, $auto, $sign, $log, $chgspec, $revspec);
    die unless GetOptions ("C|check-only"	=> \$check_only,
			   "m|message=s"	=> \$message,
			   "s|sign"		=> \$sign,
			   "l|log"		=> \$log,
			   "c|change=s",	=> \$chgspec,
			   "r|revision=s"	=> \$revspec);

    my ($src, $dst) = @ARGV;

    # XXX: support checkonly
    die "revision required" unless $revspec || $chgspec;
    my ($fromrev, $torev);
    if ($revspec) {
	($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	    or die "revision must be N:M";
    }

    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $copath) = find_repos_from_co_maybe ($dst, 0);
    my $dest_repos = 1 unless defined $copath;

    die "different repos?" unless $repospath eq $drepospath;

    my ($base_path, $base_rev) = find_merge_base ($repos, $path, $dpath);

    # find a branch target
    die "can't find a path for tmp branch" if $base_path eq '/';
    my $tmpbranch = "$path-merge-$$";

    SVN::XD::do_copy_direct ($info,
			     repospath => $repospath,
			     repos => $repos,
			     dpath => $tmpbranch,
			     message => "preparing for cherry picking merging",
			     path => $base_path,
			     rev => $base_rev,
			    ) unless $check_only;

    my $fs = $repos->fs;
    my $ceditor = SVN::CombineEditor->new(tgt_anchor => $base_path, #$check_only ? $base_path : $tmpbranch,
					  base_root  => $fs->revision_root ($base_rev),
					  pool => SVN::Pool->new,
					 );

    my @chgs = split ',', $chgspec;
    for (@chgs) {
	# back to normally auto merge if $fromrev is what we get from the base
	my ($fromrev, $torev);
	if (($fromrev, $torev) = m/^(\d+):(\d+)$/) {
	    --$fromrev;
	}
	elsif (($torev) = m/^(\d+)$/) {
	    $fromrev = $torev - 1;
	}
	else {
	    die "chgspec not recognized";
	}

	print "merging with base $base_path $base_rev applying $path $fromrev:$torev\n";

	my $fs = $repos->fs;
	my $editor = SVN::MergeEditor->new
	    ( anchor => $path,
	      base_anchor => $path,
	      base_root => $fs->revision_root ($fromrev),
	      target => '',
	      send_fulltext => 1,
	      cb_exist => sub { $ceditor->cb_exist (@_) },
	      cb_localmod => sub { $ceditor->cb_localmod (@_) },
	      cb_rev => sub { $fs->youngest_rev },
	      storage => $ceditor,
	);

	SVN::Repos::dir_delta ($fs->revision_root ($fromrev),
			       $path, '',
			       $fs->revision_root ($torev), $path,
			       $editor, undef,
			       1, 1, 0, 1);
    }

    $ceditor->replay (SVN::Delta::Editor->new
		      (_debug => 0,
		       _editor => [ $repos->get_commit_editor
				    ("file://$repospath",
				     $tmpbranch,
				     $ENV{USER}, "merge $chgspec from $path",
				     sub { print "Committed revision $_[0].\n" })
				  ]),
		      $fs->youngest_rev);
    my $newrev = $repos->fs->youngest_rev;
    my $uuid = $repos->fs->get_uuid;

    # give ticket to src
    my $ticket = find_merge_sources ($repos, $path, 1, 1);

    $ticket .= "\n$uuid:$tmpbranch:$newrev";

    SVN::XD::do_propset_direct ($info,
				author => $ENV{USER},
				repospath => $repospath,
				propname => 'svk:merge',
				propvalue => $ticket,
				repos => $repos,
				path => $path,
				message => "cherry picking merge $chgspec to $dst",
			       ) unless $check_only;
    my ($depot) = find_depotname ($src);

    merge ('-a', ($message) ? ('-m', $message) : (), "/$depot$tmpbranch", $dst);
}

=head2 mirror

Initialize a mirrored depotpath.

  usage: mirror DEPOTPATH SOURCEURL

=cut

sub mirror {
    my ($dpath, $source) = @_;
    die "require SVN::Mirror" unless $svn_mirror;
    my ($repospath, $path) = find_repos ($dpath);

    my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
			      pool => SVN::Pool->new, auth => $auth,
			      source => $source, target_create => 1);
    $m->init;
}

=head2 sync (sy)

Syncrhonize a mirrored depotpath.

  usage: sync [DEPOTPATH...]

  options:
    -s [--skipto]:          start revision
    -t [--torev]:           end revision

=cut

sub sync {
    local @ARGV = @_;
    my ($check_only, $message, $revspec);
    my ($skip_to, $sync_all, $torev);
    die unless GetOptions ("s|skipto=s"	=> \$skip_to,
			   "a|all"	=> \$sync_all,
			   "t|torev=s"	=> \$torev);
    die "require SVN::Mirror" unless $svn_mirror;

    die "argument skipto not allowed when multiple target specified"
	if $#ARGV > 0 && $skip_to;

    if ($sync_all) {
	my (undef, undef, $repos) = find_repos ($ARGV[0] || '//', 1);
	@ARGV = map {'/'.$_} SVN::Mirror::list_mirror ($repos);
    }


    for my $dpath (@ARGV) {
	my ($repospath, $path) = find_repos ($dpath);

	my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
				  pool => SVN::Pool->new, auth => $auth,
				  get_source => 1, skip_to => $skip_to);
	$m->init ();
	$m->run ($torev);
    }
}

=head2 import

Import directory into depot.

  usage: import [DEPOTPATH] [PATH]

  options:
    -m message:        commit message
    -C [--check-only]: don't perform actual writes

=cut

sub import {
    local @ARGV = @_;
    my ($check_only, $message, $auto, $log, $no_ticket, $revspec);
    die unless GetOptions ("C|check-only"	=> \$check_only,
			   "m|message=s"	=> \$message);

    my ($src, $dst) = @ARGV;
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    $dst = Cwd::abs_path ($dst || '');

    unless (defined $message || $check_only) {
	$message = get_buffer_from_editor
	    ('log message', $target_prompt, 
	     "\n$target_prompt\n", "svk-commitXXXXX");
    }

    SVN::XD::do_import ($info,
			depotpath => $src,
			repos => $repos,
			repospath => $repospath,
			path => $path,
			copath => $dst,
			check_only => $check_only,
			message => $message
		       );
}

*co = *checkout;
*up = *update;
*st = *status;
*blame = *annotate;
*ci = *commit;
*del = *rm = *delete;
*ps = *propset;
*pe = *propedit;
*pl = *proplist;
*cp = *copy;
*sm = *smerge;
*sy = *sync;
*desc = *describe;
*ver = *version;

my $show_version;

my $cmd = shift;

GetOptions ("version"  => \$show_version) unless $cmd;

if ($show_version) {
    version();
    exit 0;
}

no strict 'refs';

#$xd = SVN::XD->new (%$info);

if ($0 eq __FILE__) {
    if ($cmd && $cmd !~ m/_/ && main->can($cmd)) {
	_init();

	$SIG{INT} = sub {
	    _update_info();
	    die "interrupted\n";
	};

	&$cmd(@ARGV);
	_update_info()
    }
    else {
	print "command not recognized, try $0 help\n";
    }
}

END {
    my $svkpath = "$ENV{HOME}/.svk";
    return unless -e "$svkpath/lock";
    warn "cleaning up after excepton";
    unlink ("$svkpath/lock");
}

#%$info = %$xd;
1;

=head1 AUTHORS

Chia-liang Kao E<lt>clkao@clkao.orgE<gt>

=head1 COPYRIGHT

Copyright 2003 by Chia-liang Kao E<lt>clkao@clkao.orgE<gt>.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
