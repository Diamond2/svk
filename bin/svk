#!/usr/bin/perl -w
use strict;
require SVN::Core;
require SVN::Repos;
require SVN::Fs;
use SVN::XD;
use YAML qw(LoadFile DumpFile);
use Getopt::Long;
use File::Spec;
use Data::Hierarchy;

use vars qw/$xd $info/;
use subs qw/co up st blame ci del rm ps pl cp/;

my $svn_mirror;
eval 'require SVN::Mirror' and ++$svn_mirror;

my $auth = SVN::Core::auth_open
    ([SVN::Client::get_simple_provider (),
      SVN::Client::get_ssl_server_trust_file_provider (),
      SVN::Client::get_username_provider ()]);

=head1 NAME

svk - subversion keeper command line interface

=head1 SYNOPSIS


=head1 DESCRIPTION


=cut

sub init {
    if (-d "$ENV{HOME}/.svk") {
	$info = LoadFile ("$ENV{HOME}/.svk/config");
    }
    else {
	mkdir "$ENV{HOME}/.svk";
    }

    $info ||= { depotmap => {'' => "$ENV{HOME}/svn/svm" },
	        checkout => Data::Hierarchy->new(),
	      };
}

sub update_info {
    DumpFile ("$ENV{HOME}/.svk/config", $info)
}

sub find_repos {
    my ($depotpath, $open) = @_;
    my ($depot, $path) = $depotpath =~ m|^/(\w*)(/.*)/?$|
	or die "not depot spec";

    my $repospath = $info->{depotmap}{$depot} or die "no such depot: $depot";

    return ($repospath, $path, $open && SVN::Repos::open ($repospath));
}

sub find_repos_from_co {
    my ($copath, $open) = @_;
    $copath = File::Spec->rel2abs ($copath || '');

    my ($cinfo, $coroot) = $info->{checkout}->get ($copath);
    die "$copath not a checkout path" unless %$cinfo;
    my ($repospath, $path, $repos) = find_repos ($cinfo->{depotpath}, $open);

    if ($copath eq $coroot) {
	$copath = '';
    }
    else {
	$copath =~ s|^$coroot/|/|;
    }

    return ($repospath, $path eq '/' ? $copath : $path.$copath,
	    $cinfo, $repos);
}


=head2 update / up

    svk update

=cut

sub update {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);

    my ($copath) = @ARGV;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    $copath = File::Spec->rel2abs ($copath || '');

    # XXX: support via reporter facility in the future

    $rev = $repos->fs->youngest_rev unless defined $rev;

    SVN::XD::do_update ($info,
			repos => $repos,
			depotpath => $cinfo->{depotpath},
			copath => $copath,
			repospath => $repospath,
			path => $path,
			rev => $rev,
		       );
}

=head2 checkout / co

    svk checkout

=cut

sub checkout {
    local @ARGV = @_;
    my $rev = 0;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($depotpath, $copath) = @ARGV;

    my ($repospath, $path) = find_repos ($depotpath, 0);
    die "don't know where to checkout" unless $copath || $path ne '/';
    # FIXME: work on path inside depot should always use UNIX File::Spec
    $copath = File::Spec->rel2abs ($copath ||
				   (File::Spec->splitdir($path))[-1]);

    die "checkout path $copath already exists" if -e $copath;

    if (my ($entry, @where) = $info->{checkout}->get ($copath)) {
	die "overlapping checkout path not supported yet ($where[-1])"
	    if exists $entry->{depotpath} && $where[-1] ne $copath;
    }

    mkdir ($copath);
    $info->{checkout}->store_recursively ($copath, {depotpath => $depotpath, revision =>0});

    update ($copath, $rev)
}

=head2 info

    svk info

=cut

sub info {
    local @ARGV = @_;
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my $depotpath = $info->{checkout}->get ($copath)->{depotpath}
	or die "$copath not a checkout path";
    my ($depot, undef) = $depotpath =~ m|^/(\w*)(/.*)/?$|;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $rev = $cinfo->{revision};
    print "Depot Path: /$depot$path\n";
    print "Revision: $rev\n";
    print "Last Changed Rev: ".
	$repos->fs->revision_root ($rev)->node_created_rev ($path)."\n";
}

=head2 diff

    svk diff

=cut

use Text::Diff ();

sub diff {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
#			       cb_unknown =>
#			       sub {
#				   print "?  $_[1]\n";
#			       },
			       cb_add =>
			       sub {
				   return if -d $_[1];
				   print "Index: $_[0]\n";
				   print '=' x 66;
				   print "\n";
				   open my ($fh), $_[1];
				   print Text::Diff::diff (\'', $fh);
			       },
			       cb_changed =>
			       sub {
				   my $content = $_[2]->file_contents($_[0]);
				   print "Index: $_[0]\n";
				   print '=' x 66;
				   print "\n";
				   local $/;
				   $content = <$content>;
				   my $fh = SVN::XD::get_fh
				       ($_[2], '<', $_[0], $_[1]);
				   print Text::Diff::diff (\$content, $fh)
			       },
			      );

}

=head2 status / st

    svk status

=cut

sub status {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       cb_unknown =>
			       sub {
				   return if $_[1] =~ m/~$/;
				   print "?  $_[1]\n";
			       },
			       cb_add =>
			       sub {
				   print "A  $_[1]\n";
			       },
			       cb_delete =>
			       sub {
				   print "D  $_[1]\n";
			       },
			       cb_prop =>
			       sub {
				   print " M $_[1]\n";
			       },
			       cb_changed =>
			       sub {
				   print "M  $_[1]\n";
			       },
			      );

}

=head2 annotate / blame

    svk annotate

=cut

use Algorithm::Annotate;

sub annotate {
    local @ARGV = @_;
    my $cross = 0;
    die unless GetOptions ("x|cross"  => \$cross);
    my ($copath) = @ARGV;
    my ($repospath, $path, $repos) = eval { find_repos ($copath, 1) };
    if ($repospath) {
	undef $copath;
    }
    else {
	($repospath, $path, undef, $repos) = find_repos_from_co ($copath, 1);
    }

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $ann = Algorithm::Annotate->new;
    my @revs;
    my $hist = $root->node_history ($path);

    while ($hist = $hist->prev($cross)) {
	my ($path, $rev) = $hist->location;
	unshift @revs, $rev;
    }

    print "Annotations for $path (".($#revs+1)." active revisions)\n";
    print '*' x 16;
    print "\n";
    my $pool = SVN::Pool->new_default;
    for (@revs) {
	$pool->clear;
	local $/;
	my $content = $fs->revision_root($_)->file_contents($path);
	$content = [split "[\n\r]", <$content>];
	$ann->add ( sprintf("%6s\t(%8s %10s):\t\t", $_,
			    $fs->revision_prop ($_, 'svn:author'),
			    substr($fs->revision_prop ($_, 'svn:date'),0,10)),
		    $content);
    }

    my $final;
    if ($copath) {
	open $final, $copath;
	$ann->add ( "\t(working copy): \t\t", [map {chomp;$_}<$final>]);
	seek $final, 0, 0;
    }
    else {
	$final = $fs->revision_root($revs[-1])->file_contents($path);
    }
    my $result = $ann->result;
    while (my $info = shift @$result) {
	print $info.<$final>;
    }

}

=head2 add

=cut

sub add {
    local @ARGV = @_;
    my $nrec = 0;
    die unless GetOptions ("N|non-recursive"	=> \$nrec);

    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo) = find_repos_from_co ($copath, 0);

    SVN::XD::do_add ($info,
		     copath => $copath,
		     path => $path,
		     recursive => !$nrec,
		    );
}

=head2 delete

=cut

sub delete {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_delete ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
		       );
}

=head2 proplist / pl

=cut

sub proplist {
    local @ARGV = @_;
    my $verbose = 0;
    my $rev;

    die unless GetOptions ("v|verbose"	=> \$verbose,
			   "r|revision=i" => \$rev);

    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my $props = SVN::XD::do_proplist ($info,
				      repos => $repos,
				      copath => $copath,
				      path => $path,
				      rev => $rev,
				     );
    return unless %$props;
    print "Properties on $copath:\n";
    while (my ($key, $value) = each (%$props)) {
	print "$key: $value\n";
    }
}

=head2 propset / ps

=cut

sub propset {
    my ($pname, $pvalue, $copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_propset ($info,
			 propname => $pname,
			 propvalue => $pvalue,
			 repos => $repos,
			 copath => $copath,
			 path => $path,
			);
}

=head2 revert

=cut

sub revert {
    local @ARGV = @_;
    my $rec = 0;
    die unless GetOptions ("R|recursive"	=> \$rec);

    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_revert ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
			recursive => $rec,
		       );
}

=head2 log

    svk log

=cut

sub log {
    local @ARGV = @_;
    my ($limit, $revspec, $cross, $verbose) = (undef, undef, 0, 0);
    die unless GetOptions ("l|limit=i"		=> \$limit,
			   "r|revision=s"	=> \$revspec,
			   "x|cross"		=> \$cross,
			   "v|verbose"		=> \$verbose);

    my ($tgt) = @ARGV;
    my ($repospath, $path, $repos);
    unless (($repospath, $path, $repos) = eval { find_repos ($tgt, 1) }) {
	($repospath, $path, undef, $repos) = find_repos_from_co ($tgt, 1);
    }
    my $fs = $repos->fs;
    my ($fromrev, $torev) = ($fs->youngest_rev);
    if ($limit) {
	my $hist = $fs->revision_root ($fromrev)->node_history ($path);
	while (($hist = $hist->prev($cross)) && $limit--) {
	    $torev = ($hist->location)[1];
	}
    }

    print ('-' x 70);
    print "\n";
    $repos->get_logs ([$path], $fromrev, $torev, $verbose, !$cross,
		     sub { my ($paths, $rev, $author, $date, $message) = @_;
			   print "rev $rev:  $author | $date\n";
			   if ($paths) {
			       print "Changed paths:\n";
			       for (keys %$paths) {
				   print '  '.$paths->{$_}->action." $_\n";
			       }
			   }
			   print "\n$message\n";
			   print ('-' x 70);
			   print "\n";
		       });

}

=head2 commit / ci

    svk commit

=cut

my $target_prompt = '=== below are targets to be committed ===';
use File::Temp qw/:mktemp/;

sub get_commit_message {
    my ($file) = @_;
    while (1) {
	my $mtime = (stat($file))[7];
	my $ans;
	print "waiting for editor...\n";
	system ("\$EDITOR $file");
	last if (stat($file))[7] > $mtime;
	do {
	    print "log message not modified: a)bort, e)dit, c)ommit?\n";
	    $ans = <STDIN>;
	    chomp $ans;
	    die "Aborted" if $ans eq 'a';
	}
	    while ($ans !~ m/^[aec]/);
    }
}

sub commit {
    local @ARGV = @_;
    my $message;
    die unless GetOptions ("m|message=s"  => \$message);
    my ($fh, $file);

    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $targets;
    # harvest
    unless ($message) {
	($fh, $file) = mkstemps("svk-commitXXXXX", '.tmp');
    }

    print $fh "\n$target_prompt\n" if $fh;
    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       delete_only_parent => 1,
			       cb_unknown =>
			       sub {},
			       cb_add =>
			       sub {
				   push @$targets, ['A', $_[1]];
				   print $fh "A  $_[1]\n" if $fh;
			       },
			       cb_prop =>
			       sub {
				   push @$targets, ['P', $_[1]];
				   print $fh " M $_[1]\n" if $fh;
			       },
			       cb_delete =>
			       sub {
				   push @$targets, ['D', $_[1]];
				   print $fh "D  $_[1]\n" if $fh;
			       },
			       cb_changed =>
			       sub {
				   push @$targets, ['M', $_[1]];
				   print $fh "M  $_[1]\n" if $fh;
			       },
			      );

    die "no targets to commit" if $#{$targets} < 0;

    if ($fh) {
	close $fh;
	get_commit_message ($file);
	open $fh, '<', $file;
	local $/;
	$message = <$fh>;
	my $target;
	($message, $target) = split ("\n$target_prompt\n", $message, 2);
	# XXX: parse and check target sanity
	close $fh;
	unlink $file;
    }

    # if $copath itself is a file or is in the targets,
    # should get the anchor instead, tweak copath for the s// in XD.pm

    SVN::XD::do_commit ($info,
			author => $ENV{USER},
			message => $message,
			repos => $repos,
			repospath => $repospath,
			copath => $copath,
			path => $path,
			baserev => $cinfo->{revision},
			targets => $targets,
		       );
}

=head2 copy / cp

    svk copy

=cut

sub copy {
    local @ARGV = @_;
    my $message;
    my $rev;
    die unless GetOptions ("m|message=s"  => \$message,
			   "r|revision=i" => \$rev);
    my ($fh, $file);

    my ($src, $dst) = @ARGV;
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $editor, $copath);
    unless (($drepospath, $dpath) = eval { find_repos ($dst, 0) }) {
	die "copy doesn't work on checkout yet";
    }

    die "different repos?" if $repospath ne $drepospath;

    SVN::XD::do_copy_direct ($info,
			     repospath => $repospath,
			     repos => $repos,
			     path => $path,
			     dpath => $dpath,
			     message => $message,
			     rev => $rev || $repos->fs->youngest_rev,
			    );
}

=head2 merge

    svk merge

=cut

sub merge {
    local @ARGV = @_;
    my ($check_only, $message, $revspec);
    die unless GetOptions ("C|check-only"	=> \$check_only,
			   "m|message=s"	=> \$message,
			   "r|revision=s"	=> \$revspec);

    die "revision required" unless $revspec;
    my ($src, $dst) = @ARGV;
    my ($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	or die "revision must be N:M";
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $editor, $base_rev, $copath);
    if (($drepospath, $dpath) = eval { find_repos ($dst, 0) }) {
	unless ($message || $check_only) {
	    my ($fh, $file) = mkstemps("svk-commitXXXXX", '.tmp');
	    print $fh "$target_prompt\n";
	    close $fh;
	    get_commit_message ($file);
	    open $fh, '<', $file;
	    local $/;
	    $message = <$fh>;
	    my $target;
	    ($message, undef) = split ("\n$target_prompt\n", $message, 2);
	    # XXX: parse and check target sanity
	    close $fh;
	    unlink $file;
	}
	if ($svn_mirror) {
	    my $m = SVN::Mirror->new(target_path => $dpath,
				     target => $repospath,
				     pool => SVN::Pool->new, auth => $auth,
				     get_source => 1);
	    eval { $m->init };
	    unless ($@) {
		print "Merge back to SVN::Mirror source $m->{source}.\n";
		if ($check_only) {
		    print "Check against mirrored directory locally.\n";
		}
		else {
		    ($base_rev, $editor) = $m->get_merge_back_editor
			($message,
			 sub { print "Merge back committed as revision $_[0].\n" }
			);
		}
	    }
	}
    }
    else {
	undef $@;
	($drepospath, $dpath) = find_repos_from_co ($dst, 0);
	die "different repos?" unless $repospath eq $drepospath;
	$copath = File::Spec->rel2abs ($dst || '');
    }

    # support incremental merging (merge one revision by one)
    SVN::XD::do_merge ($info,
		       repos => $repos,
		       repospath => $repospath,
		       path => $path,
		       dpath => $dpath,
		       copath => $copath,
		       editor => $editor,
		       base_rev => $base_rev,
		       fromrev => $fromrev,
		       check_only => $check_only,
		       message => $message,
		       torev => $torev,
		      );
}

=head2 mirror

    svk mirror

=cut

sub mirror {
    my ($dpath, $source) = @_;
    die "require SVN::Mirror" unless $svn_mirror;
    my ($repospath, $path) = find_repos ($dpath);

    my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
			      auth => $auth,
			      source => $source, target_create => 1);
    $m->init;
}

=head2 sync

    svk sync

=cut

sub sync {
    local @ARGV = @_;
    my ($check_only, $message, $revspec);
    my $skip_to;
    die unless GetOptions ("s|skipto=s"	=> \$skip_to);
    die "require SVN::Mirror" unless $svn_mirror;

    my ($dpath) = @ARGV;
    my ($repospath, $path) = find_repos ($dpath);
    my $pool = SVN::Pool->new_default;

    my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
			      pool => $pool, auth => $auth,
			      get_source => 1, skip_to => $skip_to);
    $m->init ();
    $m->run ();
}


*co = *checkout;
*up = *update;
*st = *status;
*blame = *annotate;
*ci = *commit;
*del = *rm = *delete;
*ps = *propset;
*pl = *proplist;
*cp = *copy;

my $defaultdepot;

#die unless GetOptions ("depot=s"  => \$defaultdepot);

my $cmd = shift;

no strict 'refs';

#$xd = SVN::XD->new (%$info);

if ($0 eq __FILE__) {
    if ($cmd && main->can($cmd)) {
	init();

	$SIG{INT} = sub {
	    update_info();
	    die "interrupted\n";
	};

	&$cmd(@ARGV);
	update_info()
    }
    else {
	print "command not recognized\n";
    }
}

#%$info = %$xd;
1;
