#!/usr/bin/perl -w
$VERSION = '0.04';
use strict;
require SVN::Core;
require SVN::Repos;
require SVN::Fs;
use SVN::XD;
use YAML qw(LoadFile DumpFile);
use Getopt::Long;
use File::Spec;
use Data::Hierarchy;
use SVN::DiffEditor;

use vars qw/$xd $info/;
use subs qw/co up st blame ci del rm ps pl cp sy sm/;

my $svn_mirror;
eval 'require SVN::Mirror' and ++$svn_mirror;

my $auth = SVN::Core::auth_open
    ([SVN::Client::get_simple_provider (),
      SVN::Client::get_ssl_server_trust_file_provider (),
      SVN::Client::get_username_provider ()]);

=head1 NAME

svk - a decentralized version control system

=head1 SYNOPSIS


=head1 DESCRIPTION


=cut

=head1 COMMANDS

=cut

=head2 help

Describe the usage of this program or its subcommands.

  usage: help [SUBCOMMANDS...]

=cut

use Pod::Text;

sub help {
    my $parser = new Pod::Text->new ();
    @_ = qw/help/ unless @_;
    # XXX: the order from selected is not preserved.
    $parser->select (map {"COMMANDS/.*\\b$_\\b.*"} @_);
    $parser->parse_from_file ($0);
}

=head2 depotmap

Create or edit the depot mapping configuration.

Each line contains a map entry, the format is:

 depotname: 'path/to/repos'

=cut

sub depotmap {
    my $sep = '===edit the above depot map===';
    my $map = YAML::Dump ($info->{depotmap});
    my $new;
    do {
	$map = get_buffer_from_editor ('depot map', $sep, "$map\n$sep\n",
				       '/tmp/svk-depotmapXXXXX');
	$new = eval { YAML::Load ($map) };
	print "$@\n" if $@;
    } while ($@);
    print "New depot map saved.\n";
    $info->{depotmap} = $new;
    for my $path(values %{$info->{depotmap}}) {
	my $ans;
	next if -d $path;
	print "Repository $path does not exist, create?";
	while (<STDIN>) {
	    $ans = $1 if $_ =~ m/^([yn])/i;
	    last if $ans;
	}
	next if $ans eq 'n';
	SVN::Repos::create($path, undef, undef, undef,
			   {'bdb-txn-nosync' => '1',
			    'bdb-log-autoremove' => '1'});
    }
}

sub _init {
    if (-e "$ENV{HOME}/.svk/config") {
	$info = LoadFile ("$ENV{HOME}/.svk/config");
    }
    else {
	mkdir "$ENV{HOME}/.svk";
    }

    $info ||= { depotmap => {'' => "$ENV{HOME}/svn/svm" },
	        checkout => Data::Hierarchy->new(),
	      };
}

sub _update_info {
    DumpFile ("$ENV{HOME}/.svk/config", $info)
}

sub find_repos {
    my ($depotpath, $open) = @_;
    die "not depotspec" unless $depotpath;
    my ($depot, $path) = $depotpath =~ m|^/(\w*)(/.*)/?$|
	or die "not depot spec";

    my $repospath = $info->{depotmap}{$depot} or die "no such depot: $depot";

    return ($repospath, $path, $open && SVN::Repos::open ($repospath));
}

sub find_repos_from_co {
    my ($copath, $open) = @_;
    $copath = File::Spec->rel2abs ($copath || '');

    my ($cinfo, $coroot) = $info->{checkout}->get ($copath);
    die "$copath not a checkout path" unless %$cinfo;
    my ($repospath, $path, $repos) = find_repos ($cinfo->{depotpath}, $open);

    if ($copath eq $coroot) {
	$copath = '';
    }
    else {
	$copath =~ s|^$coroot/|/|;
    }

    return ($repospath, $path eq '/' ? $copath : $path.$copath,
	    $cinfo, $repos);
}


=head2 update (up)

Bring changes from the repository into checkout copies.

  usage: update [PATH...]

Synchronize checkout copies to revision given by -r or to HEAD
revision by deafult.

For each updated item a line will start with a character reporting the
action taken. These characters have the following meaning:

  A  Added
  D  Deleted
  U  Updated
  C  Conflict
  G  Merged
  g  Merged without actual change

A character in the first column signifies an update to the actual
file, while updates to the file's props are shown in the second
column.

=cut

sub update {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);

    push @ARGV, '' if $#ARGV < 0;
    for my $copath (@ARGV) {
	my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
	$copath = File::Spec->rel2abs ($copath);

	$rev = $repos->fs->youngest_rev unless defined $rev;

	SVN::XD::do_update ($info,
			    repos => $repos,
			    depotpath => $cinfo->{depotpath},
			    copath => $copath,
			    repospath => $repospath,
			    path => $path,
			    rev => $rev,
			   );
    }
}

=head2 checkout (co)

Check out a copy from depot.

  usage: checkout DEPOTPATH [PATH]

Note: If PATH is omitted, the basename of the DEPOTPATH will be used
as the destination.

=cut

sub checkout {
    local @ARGV = @_;
    my $rev = 0;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($depotpath, $copath) = @ARGV;

    my ($repospath, $path) = find_repos ($depotpath, 0);
    die "don't know where to checkout" unless $copath || $path ne '/';
    # FIXME: work on path inside depot should always use UNIX File::Spec
    $copath = File::Spec->rel2abs ($copath ||
				   (File::Spec->splitdir($path))[-1]);

    die "checkout path $copath already exists" if -e $copath;

    if (my ($entry, @where) = $info->{checkout}->get ($copath)) {
	die "overlapping checkout path not supported yet ($where[-1])"
	    if exists $entry->{depotpath} && $where[-1] ne $copath;
    }

    mkdir ($copath);
    $info->{checkout}->store_recursively ($copath, {depotpath => $depotpath, revision =>0});

    update ($copath);
}

=head2 info

    svk info

=cut

sub info {
    local @ARGV = @_;
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my $depotpath = $info->{checkout}->get ($copath)->{depotpath}
	or die "$copath not a checkout path";
    my ($depot, undef) = $depotpath =~ m|^/(\w*)(/.*)/?$|;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $rev = $cinfo->{revision};
    print "Depot Path: /$depot$path\n";
    print "Revision: $rev\n";
    print "Last Changed Rev: ".
	$repos->fs->revision_root ($rev)->node_created_rev ($path)."\n";
}

=head2 diff

    svk diff

=cut

use Text::Diff ();

sub diff {
    local @ARGV = @_;
    my $verbose = 0;
    my $revspec;

    die unless GetOptions ("v|verbose"	=> \$verbose,
			   "r|revision=s" => \$revspec);

    my ($tgt) = @ARGV;

    my ($repospath, $path, $cinfo, $repos);

    if (($repospath, $path, $repos) = eval { find_repos ($tgt, 1) }) {
	my ($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	    or die "require revspec";
	my $fs = $repos->fs;
	my $baseroot = $fs->revision_root ($fromrev);
	my $editor = SVN::DiffEditor->new
	    ( cb_basecontent => sub { my ($rpath) = @_;
				      my $base = $baseroot->file_contents ("$path/$rpath");
				      return $base;
				  }
	    );
	SVN::Repos::dir_delta ($baseroot,
			       $path, undef,
			       $fs->revision_root ($torev), $path,
			       $editor, undef,
			       1, 1, 0, 1);

    }
    else {
	my $copath = File::Spec->rel2abs ($tgt || '');
	($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

	my ($txn, $baseroot) = SVN::XD::create_xd_root ($info,
							path => $path,
							repos => $repos,
							copath => $copath);
	my $editor = SVN::DiffEditor->new
	    ( cb_basecontent =>
	      sub { my ($rpath) = @_;
		    $baseroot->file_contents ("$path/$rpath");
		},
	      cb_baseprop =>
	      sub { my ($rpath, $prop) = @_;
		    $baseroot->node_prop ("$path/$rpath", $prop);
	      },
	    );

	undef $@;

	SVN::XD::checkout_delta ($info,
				 repos => $repos,
				 copath => $copath,
				 path => $path,
				 xdroot => $baseroot,
				 editor => $editor,
				);
	$txn->abort if $txn;
    }
}

=head2 status (st)

    svk status

=cut

sub status {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       cb_unknown =>
			       sub {
				   return if $_[1] =~ m/~$/;
				   print "?  $_[1]\n";
			       },
			       cb_add =>
			       sub {
				   print "A  $_[1]\n";
			       },
			       cb_delete =>
			       sub {
				   print "D  $_[1]\n";
			       },
			       cb_prop =>
			       sub {
				   print " M $_[1]\n";
			       },
			       cb_changed =>
			       sub {
				   print "M  $_[1]\n";
			       },
			      );

}

=head2 annotate (blame)

    svk annotate

=cut

use Algorithm::Annotate;

sub annotate {
    local @ARGV = @_;
    my $cross = 0;
    die unless GetOptions ("x|cross"  => \$cross);
    my ($copath) = @ARGV;
    my ($repospath, $path, $repos) = eval { find_repos ($copath, 1) };
    if ($repospath) {
	undef $copath;
    }
    else {
	($repospath, $path, undef, $repos) = find_repos_from_co ($copath, 1);
    }

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $ann = Algorithm::Annotate->new;
    my @revs;
    my $hist = $root->node_history ($path);

    while ($hist = $hist->prev($cross)) {
	my ($path, $rev) = $hist->location;
	unshift @revs, $rev;
    }

    print "Annotations for $path (".($#revs+1)." active revisions)\n";
    print '*' x 16;
    print "\n";
    my $pool = SVN::Pool->new_default;
    for (@revs) {
	$pool->clear;
	local $/;
	my $content = $fs->revision_root($_)->file_contents($path);
	$content = [split "[\n\r]", <$content>];
	$ann->add ( sprintf("%6s\t(%8s %10s):\t\t", $_,
			    $fs->revision_prop ($_, 'svn:author'),
			    substr($fs->revision_prop ($_, 'svn:date'),0,10)),
		    $content);
    }

    my $final;
    if ($copath) {
	open $final, $copath;
	$ann->add ( "\t(working copy): \t\t", [map {chomp;$_}<$final>]);
	seek $final, 0, 0;
    }
    else {
	$final = $fs->revision_root($revs[-1])->file_contents($path);
    }
    my $result = $ann->result;
    while (my $info = shift @$result) {
	print $info.<$final>;
    }

}

=head2 add

=cut

sub add {
    local @ARGV = @_;
    my $nrec = 0;
    die unless GetOptions ("N|non-recursive"	=> \$nrec);

    for my $copath (@ARGV) {
	$copath = File::Spec->rel2abs ($copath || '');
	my ($repospath, $path, $cinfo) = find_repos_from_co ($copath, 0);

	SVN::XD::do_add ($info,
			 copath => $copath,
			 path => $path,
			 recursive => !$nrec,
			);
    }
}

=head2 delete

=cut

sub delete {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_delete ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
		       );
}

=head2 proplist (pl)

=cut

sub proplist {
    local @ARGV = @_;
    my $verbose = 0;
    my $rev;

    die unless GetOptions ("v|verbose"	=> \$verbose,
			   "r|revision=i" => \$rev);

    push @ARGV, '' if $#ARGV < 0;
    for my $copath (@ARGV) {
	$copath = File::Spec->rel2abs ($copath);
	my ($repospath, $path, undef, $repos) =
	    find_repos_from_co ($copath, 1);

	my $props = SVN::XD::do_proplist ($info,
					  repos => $repos,
					  copath => $copath,
					  path => $path,
					  rev => $rev,
					 );
	return unless %$props;
	print "Properties on $copath:\n";
	while (my ($key, $value) = each (%$props)) {
	    print "$key: $value\n";
	}
    }
}

=head2 propset (ps)

=cut

sub propset {
    my ($pname, $pvalue, $copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_propset ($info,
			 propname => $pname,
			 propvalue => $pvalue,
			 repos => $repos,
			 copath => $copath,
			 path => $path,
			);
}

=head2 revert

=cut

sub revert {
    local @ARGV = @_;
    my $rec = 0;
    die unless GetOptions ("R|recursive"	=> \$rec);

    for my $copath (@ARGV) {
	$copath = File::Spec->rel2abs ($copath || '');
	my ($repospath, $path, undef, $repos) =
	    find_repos_from_co ($copath, 1);

	SVN::XD::do_revert ($info,
			    repos => $repos,
			    copath => $copath,
			    path => $path,
			    recursive => $rec,
			   );
    }
}

=head2 log

Show the log messages for revisions.

  usage: 1. log DEPOTPATH
         2. log PATH

  options:
    -r [--revision]:      revision spec from:to
    -l [--limit]:         limit the number of revisions displayed
    -x [--cross]:         cross copied node
    -v [--verbose]:       print changed path in changes

=cut

sub log {
    local @ARGV = @_;
    my ($limit, $revspec, $cross, $verbose) = (undef, undef, 0, 0);
    die unless GetOptions ("l|limit=i"		=> \$limit,
			   "r|revision=s"	=> \$revspec,
			   "x|cross"		=> \$cross,
			   "v|verbose"		=> \$verbose);

    my ($tgt) = @ARGV;
    my ($repospath, $path, $repos);
    unless (($repospath, $path, $repos) = eval { find_repos ($tgt, 1) }) {
	($repospath, $path, undef, $repos) = find_repos_from_co ($tgt, 1);
    }
    my $fs = $repos->fs;
    my ($fromrev, $torev);
    ($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	or $fromrev = $torev = $revspec
	    if $revspec;
    $fromrev ||= $fs->youngest_rev;
    $torev ||= 0;

    if ($limit) {
	my $hist = $fs->revision_root ($fromrev)->node_history ($path);
	while (($hist = $hist->prev($cross)) && $limit--) {
	    $torev = ($hist->location)[1];
	}
    }

    print ('-' x 70);
    print "\n";
    $repos->get_logs ([$path], $fromrev, $torev, $verbose, !$cross,
		     sub { my ($paths, $rev, $author, $date, $message) = @_;
			   no warnings 'uninitialized';
			   print "rev $rev:  $author | $date\n";
			   if ($paths) {
			       print "Changed paths:\n";
			       for (keys %$paths) {
				   print '  '.$paths->{$_}->action." $_\n";
			       }
			   }
			   print "\n$message\n";
			   print ('-' x 70);
			   print "\n";
		       });

}

=head2 commit (ci)

Commit changes to depot.

  usage: commit [PATH...]

=cut

my $target_prompt = '=== below are targets to be committed ===';
use File::Temp qw/:mktemp/;

sub get_buffer_from_editor {
    my ($what, $sep, $content, $file) = @_;
    my $fh;
    if (defined $content) {
	($fh, $file) = mkstemps ($file, '.tmp');
	print $fh $content;
	close $file;
    }

    while (1) {
	my $mtime = (stat($file))[9];
	my $ans;
	print "waiting for editor...\n";
	system ("\$EDITOR $file");
	last if (stat($file))[9] > $mtime;
	do {
	    print "$what not modified: a)bort, e)dit, c)ommit?\n";
	    $ans = <STDIN>;
	    chomp $ans;
	    die "Aborted" if $ans eq 'a';
	}
	while ($ans !~ m/^[aec]/);
    }

    open $fh, $file;
    local $/;
    my @ret = split ("\n$sep\n", <$fh>, 2);
    close $fh;
    unlink $file;
    return wantarray ? @ret : $ret[0];
}

sub path_is_mirrored {
    my ($repos, $path) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    my $rev = ($root->node_history ($path)->prev (0)->location)[1];

    return (grep {m/^svm:headrev:/} keys %{$fs->revision_proplist ($rev)});
}

sub commit {
    local @ARGV = @_;
    my ($message, $force);
    die unless GetOptions ("m|message=s"  => \$message,
			   "force",	  => \$force,
			  );
    my ($fh, $file);

    # XXX: support multiple target
    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $targets;

    # XXX: other commands committing to target should have this check too
    die "Commit into mirrored path will ruin the mirror state!\n".
	"Use --force to override if you know what you are doing"
	    unless $force || !path_is_mirrored ($repos, $path);

    # harvest
    unless (defined $message) {
	($fh, $file) = mkstemps("svk-commitXXXXX", '.tmp');
    }

    print $fh "\n$target_prompt\n" if $fh;
    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       delete_only_parent => 1,
			       cb_unknown =>
			       sub {},
			       cb_add =>
			       sub {
				   push @$targets, ['A', $_[1]];
				   print $fh "A  $_[1]\n" if $fh;
			       },
			       cb_prop =>
			       sub {
				   push @$targets, ['P', $_[1]];
				   print $fh " M $_[1]\n" if $fh;
			       },
			       cb_delete =>
			       sub {
				   push @$targets, ['D', $_[1]];
				   print $fh "D  $_[1]\n" if $fh;
			       },
			       cb_changed =>
			       sub {
				   push @$targets, ['M', $_[1]];
				   print $fh "M  $_[1]\n" if $fh;
			       },
			      );

    die "no targets to commit" if $#{$targets} < 0;

    if ($fh) {
	close $fh;
	$message =
	    get_buffer_from_editor ('log message', $target_prompt,
				    undef, $file);
    }

    # if $copath itself is a file or is in the targets,
    # should get the anchor instead, tweak copath for the s// in XD.pm

    SVN::XD::do_commit ($info,
			author => $ENV{USER},
			message => $message,
			repos => $repos,
			repospath => $repospath,
			copath => $copath,
			path => $path,
			baserev => $cinfo->{revision},
			targets => $targets,
		       );
}

=head2 copy (cp)

    svk copy

=cut

sub copy {
    local @ARGV = @_;
    my $message;
    my $rev;
    die unless GetOptions ("m|message=s"  => \$message,
			   "r|revision=i" => \$rev);
    my ($fh, $file);

    my ($src, $dst) = @ARGV;
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $editor, $copath);
    unless (($drepospath, $dpath) = eval { find_repos ($dst, 0) }) {
	die "copy doesn't work on checkout yet";
    }

    die "different repos?" if $repospath ne $drepospath;

    $message = get_buffer_from_editor ('log message', $target_prompt,
				       "\n$target_prompt\n",
				       "/tmp/svk-commitXXXXX")
	unless defined $message;

    SVN::XD::do_copy_direct ($info,
			     repospath => $repospath,
			     repos => $repos,
			     path => $path,
			     dpath => $dpath,
			     message => $message,
			     rev => $rev || $repos->fs->youngest_rev,
			    );
}

=head2 merge

Apply the differences between two sources to a checkout copy or a
depotpath. Use -a to automatically calculate the revisions to merge 

  usage: 1. merge -r N:M DEPOTPATH [PATH]
         2. merge -r N:M DEPOTPATH1 DEPOTPATH2

  options:
    -m message:        commit message
    -C [--check-only]: don't perform actual writes
    -a [--auto]:       automatically find merge points

=cut

sub find_branch_point {
    my ($repos, $src, $dst, $safe) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    my $hist = $root->node_history ($dst);
    my ($path, $rev, $crev);
    while ($hist = $hist->prev (1)) {
	($path, $rev) = $hist->location ();
	last if $path eq $src;
	$crev = $rev if $path eq $dst;
    }
    return ($rev, $crev)
	if $path eq $src;

    die "can't find branch point for $src and $dst"
	if $safe;

    return reverse (find_branch_point ($repos, $dst, $src, 1));
}

# when is the last merge from src to dst?
sub find_merge_history {
    my ($repos, $src, $dst) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my ($m, $uuid);
    if ($svn_mirror) {
	$m = eval 'SVN::Mirror::is_mirrored ($repos, $src)';
    }

    if ($m) {
	$uuid = $root->node_prop ($src, 'svm:uuid');
	$src = $m->{source};
	$src =~ s/^$m->{source_root}//;
    }

    $uuid ||= $repos->fs->get_uuid ();

    if (my $minfo = $root->node_prop ($dst, 'svk:merge')) {
	$minfo = { map {my ($uuid, $path, $rev) = split ':', $_;
			("$uuid:$path" => $rev);
		    } split ("\n", $minfo) };
	# resolve the rev to local rev if it's svm'ed
	if (my $r = $minfo->{join (':', $uuid, $src)}) {
	    $r = $m->find_local_rev ($r)
		if $m;
	    return $r;
	}
    }
}

sub find_merge_info {
    my ($repos, $src, $dst) = @_;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    my ($mpsrc, $mpdst) = (find_merge_history ($repos, $src, $dst),
			   find_merge_history ($repos, $dst, $src));

    my ($bpsrc, $bpdst) = find_branch_point ($repos, $src, $dst);

    unless ($mpsrc || $mpdst) {
	return ($src, $bpsrc, $fs->youngest_rev);
    }

    $mpsrc ||= $bpsrc;
    $mpdst ||= $bpdst;

    return ($mpsrc > $mpdst ? $src : $dst,
	    $mpsrc > $mpdst ? $mpsrc : $mpdst,
	    $fs->youngest_rev);
}

sub resolve_svm_source {
    my ($repos, $path) = @_;
    my ($uuid, $rev, $m);
    my $mirrored;
    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);

    if ($svn_mirror) {
	$m = eval 'SVN::Mirror::is_mirrored ($repos, $path)';
    }

    if ($m) {
	$uuid = $root->node_prop ($path, 'svm:uuid');
	$path = $m->{source};
	$path =~ s/^$m->{source_root}//;
	$rev = $m->{fromrev};
    }
    else {
	($rev, $uuid) = ($fs->youngest_rev, $fs->get_uuid);
    }

    return ($uuid, $path, $rev);
}

sub get_new_ticket {
    my ($root, $dst, $uuid, $path, $rev) = @_;

    my $minfo = $root->node_prop ($dst, 'svk:merge') || '';

    $minfo = { map {my ($uuid, $path, $rev) = split ':', $_;
		    ("$uuid:$path" => $rev);
		} split ("\n", $minfo) };
    $minfo->{"$uuid:$path"} = $rev;

    return join ("\n", map {"$_:$minfo->{$_}"} sort keys %$minfo);
}

sub merge {
    local @ARGV = @_;
    my ($check_only, $message, $auto, $no_ticket, $revspec);
    die unless GetOptions ("C|check-only"	=> \$check_only,
			   "m|message=s"	=> \$message,
			   "a|auto"		=> \$auto,
			   "no-ticket"		=> \$no_ticket,
			   "r|revision=s"	=> \$revspec);

    my ($src, $dst) = @ARGV;
    my ($base_path, $fromrev, $torev, $cb_merged);
    unless ($auto) {
	die "revision required" unless $revspec;
	($fromrev, $torev) = $revspec =~ m/^(\d+):(\d+)$/
	    or die "revision must be N:M";
    }
    my ($repospath, $path, $repos) = find_repos ($src, 1);
    my ($drepospath, $dpath, $editor, $base_rev, $copath);
    if (($drepospath, $dpath) = eval { find_repos ($dst, 0) }) {
	unless (defined $message || $check_only) {
	    $message = get_buffer_from_editor
		('log message', $target_prompt,
		 "\n$target_prompt\n", "svk-commitXXXXX");
	}
	if ($svn_mirror) {
	    my $m = SVN::Mirror->new(target_path => $dpath,
				     target => $repospath,
				     pool => SVN::Pool->new, auth => $auth,
				     get_source => 1);
	    eval { $m->init };
	    unless ($@) {
		print "Merge back to SVN::Mirror source $m->{source}.\n";
		if ($check_only) {
		    print "Check against mirrored directory locally.\n";
		}
		else {
		    ($base_rev, $editor) = $m->get_merge_back_editor
			($message,
			 sub { print "Merge back committed as revision $_[0].\n" }
			);
		    $base_rev = $m->{fromrev};
		}
	    }
	}
    }
    else {
	undef $@;
	($drepospath, $dpath) = find_repos_from_co ($dst, 0);
	die "different repos?" unless $repospath eq $drepospath;
	$copath = File::Spec->rel2abs ($dst || '');
    }

    if ($auto) {
	($base_path, $fromrev, $torev) =
	    find_merge_info ($repos, $path, $dpath);
	print "auto merge ($fromrev, $torev) $path -> $dpath (base $base_path)\n";
	# XXX: resolve the uuid and torev with source path (see if it's svm'ed)
	my ($uuid, $path, $rev) = resolve_svm_source ($repos, $path);
	print "merge ticket: $uuid:$path:$rev\n" unless $no_ticket;
	# XXX: cb_merged for XD
	my $root = $repos->fs->revision_root ($repos->fs->youngest_rev);
	$cb_merged = sub { my ($editor, $baton, $pool) = @_;
			   # XXX: have to be multiple-safe
			   $editor->change_dir_prop
			       ($baton, 'svk:merge',
				get_new_ticket ($root, $dpath, $uuid,
						$path, $rev));
		       } unless $no_ticket;
    }

    # support incremental merging (merge one revision by one)
    SVN::XD::do_merge ($info,
		       repos => $repos,
		       repospath => $repospath,
		       path => $path,
		       dpath => $dpath,
		       copath => $copath,
		       editor => $editor,
		       send_fulltext => $editor ? 0 : 1,
		       base_path => $base_path,
		       base_rev => $base_rev,
		       fromrev => $fromrev,
		       check_only => $check_only,
		       message => $message,
		       torev => $torev,
		       cb_merged => $cb_merged,
		      );
}

=head2 smerge (sm)

Alias to merge -a.

=cut

sub smerge {
    merge ('-a', @_);
}

=head2 mirror

Initialize a mirrored depotpath.

  usage: sync DEPOTPATH SOURCEURL

=cut

sub mirror {
    my ($dpath, $source) = @_;
    die "require SVN::Mirror" unless $svn_mirror;
    my ($repospath, $path) = find_repos ($dpath);

    my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
			      pool => SVN::Pool->new, auth => $auth,
			      source => $source, target_create => 1);
    $m->init;
}

=head2 sync (sy)

Syncrhonize a mirrored depotpath.

  usage: sync [DEPOTPATH...]

=cut

sub sync {
    local @ARGV = @_;
    my ($check_only, $message, $revspec);
    my ($skip_to, $torev);
    die unless GetOptions ("s|skipto=s"	=> \$skip_to,
			   "t|torev=s"	=> \$torev);
    die "require SVN::Mirror" unless $svn_mirror;

    die "argument skipto not allowed when multiple target specified"
	if $#ARGV > 0 && $skip_to;

    for my $dpath (@ARGV) {
	my ($repospath, $path) = find_repos ($dpath);

	my $m = SVN::Mirror->new (target_path => $path, target => $repospath,
				  pool => SVN::Pool->new, auth => $auth,
				  get_source => 1, skip_to => $skip_to);
	$m->init ();
	$m->run ($torev);
    }
}


*co = *checkout;
*up = *update;
*st = *status;
*blame = *annotate;
*ci = *commit;
*del = *rm = *delete;
*ps = *propset;
*pl = *proplist;
*cp = *copy;
*sm = *smerge;
*sy = *sync;

my $defaultdepot;

#die unless GetOptions ("depot=s"  => \$defaultdepot);

my $cmd = shift;

no strict 'refs';

#$xd = SVN::XD->new (%$info);

if ($0 eq __FILE__) {
    if ($cmd && $cmd !~ m/_/ && main->can($cmd)) {
	_init();

	$SIG{INT} = sub {
	    _update_info();
	    die "interrupted\n";
	};

	&$cmd(@ARGV);
	_update_info()
    }
    else {
	print "command not recognized, try $0 help\n";
    }
}

#%$info = %$xd;
1;

=head1 AUTHORS

Chia-liang Kao E<lt>clkao@clkao.orgE<gt>

=head1 COPYRIGHT

Copyright 2003 by Chia-liang Kao E<lt>clkao@clkao.orgE<gt>.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut
