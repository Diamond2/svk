#!/usr/bin/perl -w
use strict;
require SVN::Core;
require SVN::Repos;
require SVN::Fs;
use SVN::XD;
use YAML qw(LoadFile DumpFile);
use Getopt::Long;
use File::Spec;
use Data::Hierarchy;

use vars qw/$xd $info/;
use subs qw/co up st blame ci del rm ps/;

=head1 NAME

svk - subversion keeper command line interface

=head1 SYNOPSIS


=head1 DESCRIPTION


=cut

sub init {
    if (-d "$ENV{HOME}/.svk") {
	$info = LoadFile ("$ENV{HOME}/.svk/config");
    }
    else {
	mkdir "$ENV{HOME}/.svk";
    }

    $info ||= { depotmap => {'' => "$ENV{HOME}/svn/svm" },
	        checkout => Data::Hierarchy->new(),
	      };
}

sub update_info {
    DumpFile ("$ENV{HOME}/.svk/config", $info)
}

sub find_repos {
    my ($depotpath, $open) = @_;
    my ($depot, $path) = $depotpath =~ m|^/(\w*)(/.*)/?$|;

    my $repospath = $info->{depotmap}{$depot} or die "no such depot: $depot";

    return ($repospath, $path, $open && SVN::Repos::open ($repospath));
}

sub find_repos_from_co {
    my ($copath, $open) = @_;
    $copath = File::Spec->rel2abs ($copath || '');

    my ($cinfo, $coroot) = $info->{checkout}->get ($copath);
    die "$copath not a checkout path" unless %$cinfo;
    my ($repospath, $path, $repos) = find_repos ($cinfo->{depotpath}, $open);

    if ($copath eq $coroot) {
	$copath = '';
    }
    else {
	$copath =~ s|^$coroot/|/|;
    }

    return ($repospath, $path.$copath, $cinfo, $repos);
}


=head2 update / up

    svk update

=cut

sub update {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);

    my ($copath) = @ARGV;
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    $copath = File::Spec->rel2abs ($copath || '');

    # XXX: support via reporter facility in the future

    $rev = $repos->fs->youngest_rev unless defined $rev;

    SVN::XD::do_update ($info,
			repos => $repos,
			depotpath => $cinfo->{depotpath},
			copath => $copath,
			repospath => $repospath,
			path => $path,
			rev => $rev,
		       );
}

=head2 checkout / co

    svk checkout

=cut

sub checkout {
    local @ARGV = @_;
    my $rev;
    die unless GetOptions ("r|revision=i"  => \$rev);
    my ($depotpath, $copath) = @ARGV;

    my ($repospath, $path) = find_repos ($depotpath, 0);
    die "don't know where to checkout" unless $copath || $path ne '/';
    # FIXME: work on path inside depot should always use UNIX File::Spec
    $copath = File::Spec->rel2abs ($copath ||
				   (File::Spec->splitdir($path))[-1]);

    die "checkout path $copath already exists" if -e $copath;

    mkdir ($copath);
    $info->{checkout}->store_recursively ($copath, {depotpath => $depotpath, revision =>0});

    update ($copath, $rev)
}

=head2 diff

    svk diff

=cut

use Text::Diff ();

sub diff {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
#			       cb_unknown =>
#			       sub {
#				   print "?  $_[1]\n";
#			       },
			       cb_add =>
			       sub {
				   print Text::Diff::diff (\'', $_[1]);
			       },
			       cb_changed =>
			       sub {
				   my $content = $_[2]->file_contents($_[0]);
				   print "Index: $_[0]\n";
				   print '=' x 66;
				   print "\n";
				   local $/;
				   $content = <$content>;
				   print Text::Diff::diff (\$content, $_[1])
			       },
			      );

}

=head2 status / st

    svk status

=cut

sub status {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       cb_unknown =>
			       sub {
				   print "?  $_[1]\n";
			       },
			       cb_add =>
			       sub {
				   print "A  $_[1]\n";
			       },
			       cb_delete =>
			       sub {
				   print "D  $_[1]\n";
			       },
			       cb_prop =>
			       sub {
				   print " M $_[1]\n";
			       },
			       cb_changed =>
			       sub {
				   print "M  $_[1]\n";
			       },
			      );

}

=head2 annotate / blame

    svk annotate

=cut

use Algorithm::Annotate;

sub annotate {
    local @ARGV = @_;
    my $cross = 0;
    die unless GetOptions ("x|cross"  => \$cross);
    my ($copath) = @ARGV;

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    my $fs = $repos->fs;
    my $root = $fs->revision_root ($fs->youngest_rev);
    my $ann = Algorithm::Annotate->new;
    my @revs;
    my $hist = $root->node_history ($path);

    while ($hist = $hist->prev($cross)) {
	my ($path, $rev) = $hist->location;
	unshift @revs, $rev;
    }

    print "Annotations for $path (".($#revs+1)." active revisions)\n";
    print '*' x 16;
    print "\n";
    my $pool = SVN::Pool->new_default;
    for (@revs) {
	$pool->clear;
	local $/;
	my $content = $fs->revision_root($_)->file_contents($path);
	$content = [split "[\n\r]", <$content>];
	$ann->add ( sprintf("%6s\t(%8s %10s):\t\t", $_,
			    $fs->revision_prop ($_, 'svn:author'),
			    substr($fs->revision_prop ($_, 'svn:date'),0,10)),
		    $content);
    }

    open my ($fh), $copath;

    $ann->add ( "\t(working copy): \t\t", [map {chomp;$_}<$fh>]);

    seek $fh, 0, 0;

    my $result = $ann->result;
    while (my $info = shift @$result) {
	print $info.<$fh>;
    }

}

=head2 add

=cut

sub add {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo) = find_repos_from_co ($copath, 0);

    SVN::XD::do_add ($info,
		     copath => $copath,
		     path => $path,
		    );
}

=head2 delete

=cut

sub delete {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_delete ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
		       );
}

=head2 propset / ps

=cut

sub propset {
    my ($pname, $pvalue, $copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_propset ($info,
			 propname => $pname,
			 propvalue => $pvalue,
			 repos => $repos,
			 copath => $copath,
			 path => $path,
			);
}

=head2 revert

=cut

sub revert {
    my ($copath) = @_;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);

    SVN::XD::do_revert ($info,
			repos => $repos,
			copath => $copath,
			path => $path,
		       );
}

=head2 log

    svk log

=cut

sub log {
    local @ARGV = @_;
    my ($limit, $revspec, $cross, $verbose) = (undef, undef, 0, 0);
    die unless GetOptions ("l|limit=i"		=> \$limit,
			   "r|revision=s"	=> \$revspec,
			   "x|cross"		=> \$cross,
			   "v|verbose"		=> \$verbose);

    my ($copath) = @ARGV;

    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $fs = $repos->fs;
    my ($fromrev, $torev) = ($fs->youngest_rev);
    if ($limit) {
	my $hist = $fs->revision_root ($fromrev)->node_history ($path);
	while (($hist = $hist->prev($cross)) && $limit--) {
	    $torev = ($hist->location)[1];
	}
    }

    print ('-' x 70);
    print "\n";
    $repos->get_logs ([$path], $fromrev, $torev, $verbose, !$cross,
		     sub { my ($paths, $rev, $author, $date, $message) = @_;
			   print "rev $rev:  $author | $date\n";
			   if ($paths) {
			       print "Changed paths:\n";
			       for (keys %$paths) {
				   print '  '.$paths->{$_}->action." $_\n";
			       }
			   }
			   print "\n$message\n";
			   print ('-' x 70);
			   print "\n";
		       });

}

=head2 commit / ci

    svk commit

=cut

my $target_prompt = '=== below are targets to be committed ===';
use File::Temp qw/:mktemp/;

sub commit {
    local @ARGV = @_;
    my $message;
    die unless GetOptions ("m|message=s"  => \$message);
    my ($fh, $file);

    my ($copath) = @ARGV;
    $copath = File::Spec->rel2abs ($copath || '');
    my ($repospath, $path, $cinfo, $repos) = find_repos_from_co ($copath, 1);
    my $targets;
    # harvest
    unless ($message) {
	($fh, $file) = mkstemps("svk-commitXXXXX", '.tmp');
    }

    print $fh "\n$target_prompt\n" if $fh;
    SVN::XD::checkout_crawler ($info,
			       repos => $repos,
			       copath => $copath,
			       path => $path,
			       rev => $cinfo->{revision},
			       delete_only_parent => 1,
			       cb_unknown =>
			       sub {},
			       cb_add =>
			       sub {
				   push @$targets, ['A', $_[1]];
				   print $fh "A  $_[1]\n" if $fh;
			       },
			       cb_delete =>
			       sub {
				   push @$targets, ['D', $_[1]];
				   print $fh "D  $_[1]\n" if $fh;
			       },
			       cb_changed =>
			       sub {
				   push @$targets, ['M', $_[1]];
				   print $fh "M  $_[1]\n" if $fh;
			       },
			      );

    if ($fh) {
	close $fh;
	while (1) {
	    my $mtime = (stat($file))[7];
	    my $ans;
	    print "waiting for editor...\n";
	    system ("\$EDITOR $file");
	    last if (stat($file))[7] > $mtime;
	    do {
		print "log message not modified: a)bort, e)dit, c)ommit?\n";
		$ans = <STDIN>;
		chomp $ans;
		die "Aborted" if $ans eq 'a';
	    }
	    while ($ans !~ m/^[aec]/);
	}
	open $fh, '<', $file;
	local $/;
	$message = <$fh>;
	my $target;
	($message, $target) = split ("\n$target_prompt\n", $message, 2);
	# XXX: parse and check target sanity
	close $fh;
	unlink $file;
    }

    # if $copath itself is a file or is in the targets,
    # should get the anchor instead, tweak copath for the s// in XD.pm

    SVN::XD::do_commit ($info,
			author => $ENV{USER},
			message => $message,
			repos => $repos,
			repospath => $repospath,
			copath => $copath,
			path => $path,
			baserev => $cinfo->{revision},
			targets => $targets,
		       );
}

*co = *checkout;
*up = *update;
*st = *status;
*blame = *annotate;
*ci = *commit;
*del = *rm = *delete;
*ps = *propset;

my $defaultdepot;

#die unless GetOptions ("depot=s"  => \$defaultdepot);

my $cmd = shift;

no strict 'refs';

#$xd = SVN::XD->new (%$info);

$SIG{INT} = sub {
    update_info();
    die "interrupted\n";
};

if (main->can($cmd)) {
    init();
    &$cmd(@ARGV);
    update_info()
}
else {
    print "command not recognized\n";
}

#%$info = %$xd;
