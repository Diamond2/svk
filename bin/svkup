#!/usr/bin/perl -w
use strict;
use SVN::Core;
use IO::Socket::INET;
#use PerlIO::gzip;
use SVK::XD;
use Data::Hierarchy;
use SVK::Editor::Local;
use SVK::Editor::Network;
use SVK::Target;
use SVK::Util qw(slurp_fh);
use YAML;

=head2 TODO

=over

=item on base checksum mismatch, issue oob retrieval, or fixup at the
end (need to serialize the textdelta though.

=item signature caching

=back

=cut

die "Usage: $0 <server> <copath> [target]\n" if $#ARGV < 1;
my ($server, $copath, $target) = @ARGV;
my $resource;

$server .= ':3699' unless index ($server, ':') >= 0;

if (-e $copath) {
    die unless -d $copath;
    open my $fh, '<', "$copath/.svkup" or die $!;
    $resource = <$fh>;
    chomp $resource;
    unless ($target) {
	$target = $resource;
	$target =~ s/:\d+$//;
    }
}
else {
    mkdir $copath or die $!;
    $resource = $target;
    $resource =~ s/:\d+$/:0/ or $resource .= ':0';
}

my %handler;
my $myreq = 1;
my $iostat;
my $done;

sub read_msg {
    my ($sock) = @_;
    my ($len, $msg);
    read $sock, $len, 2 or die $!;
    $len = unpack ('n', $len);
    read $sock, $msg, $len or die $!;
    return \$msg;
}

sub print_msg {
    my ($error, $sock, $req) = @_;
    my $msg = read_msg ($sock);
    print "$server: $$msg\n";
    $done = 1 if $error;
}

$handler{0} = sub { print_msg (0, @_) };
$handler{65535} = sub { print_msg (1, @_) };

eval { use Time::HiRes qw(time); };

# state for editor call process
my ($closed, $hold_close);

sub main {
    my $sock = IO::Socket::INET->new ( PeerAddr => $server,
				       Blocking => 1,
				     ) or die "$server: $!";
    $sock->autoflush (1);

    my ($read, $write) = (0, 0);
    if (eval { require IO::Statistics; 1 }) {
        $iostat++;
        IO::Statistics->count (\$read, \$write, $sock);
    }

    my $t = time;
    init ($sock);

    while (!$done) {
	my $req;
	my $ret = read $sock, $req, 2;
	last if $ret == 0;
	die "$server: $! ($ret) [$req]" unless $ret > 0;
	$req = unpack ('n', $req);
	dispatch ($sock, $req);
    }

    print "Running time: ".(time - $t)."\n";
    print "Read $read bytes, wrote $write bytes\n" if $iostat;
}

sub dispatch {
    my ($sock, $req) = @_;
    die "no such request sent $req" unless exists $handler{$req};
    $handler{$req}->($sock);
}

sub send_cmd {
    my ($sock, $cmd, $handler) = @_;
    print $sock pack ('nn', $myreq, length ($cmd)), $cmd;
    $handler{$myreq} = $handler;
    ++$myreq;
}

sub init {
    my $sock = shift;
    send_cmd ($sock, "init version=1a compress transport=freezethaw\n",
	      sub {
#		  binmode $sock, ':gzip(none)' or die $!;
#		  warn "binmode on client";
		  send_delta_request (@_) });
}

sub send_delta_request {
    my $sock = shift;
    my $editor = SVK::Editor::Local->new (get_copath =>
					  sub { $_[0] = SVK::Target->copath ($copath,  $_[0]) },
					  notify =>
					  SVK::Notify->new_with_report ($copath, '', 1),
					 );
    my $dispatch = SVK::Editor::Network->new (editor => $editor);
    send_cmd ($sock, "delta $resource $target\n", sub { emit_editor_call ($dispatch, @_) });
}

use FreezeThaw qw(thaw);

sub thaw_fd {
    my ($sock) = @_;
    my ($entry) = thaw (${read_msg ($sock)});
    return $entry;
}

sub fixup_text {
    my ($dispatch, $sock, $entry, $call) = @_;
    # assert $call->[1] is apply_textdelta
    my $sca = ${read_msg ($sock)};
    open my $content, '<', \$sca or die $!;
    my $path = SVK::Target->copath ($copath, $entry);
    open my $fh, '>', $path or die $!;
    slurp_fh ($content, $fh);
    close $fh;
    $dispatch->{editor}{cb_base_checksum} =
	sub { my $path = shift;
	      die "===> checksum of $path still bad after refetch";
	  };
    $dispatch->{editor}{notify}->node_extra ($entry, 'fixed');
    $dispatch->emit ($call);
    $dispatch->emit ($hold_close->{$call->[2]})
	if ref ($hold_close->{$call->[2]});
    delete $hold_close->{$call->[2]};
    finalize ($dispatch);
}

sub finalize {
    my $dispatch = shift;
    $dispatch->{editor}{notify}->flush_dir ('', 1); # all fixed stuff
    return unless $closed and !keys %$hold_close;
    my $rev = $dispatch->{editor}{revision};
    open my $fh, '>', "$copath/.svkup" or die $!;
    $target =~ s/:\d+$/:$rev/ or $target .= ":$rev";
    print $fh "$target\n";
    $done = 1;
}

sub emit_editor_call {
    my ($dispatch, $sock) = @_;
    my $call = thaw_fd ($sock);
    # defer corresponding close_file call
    if ($call->[1] eq 'close_file' && exists $hold_close->{$call->[2]}) {
	$hold_close->{$call->[2]} = $call;
	return;
    }
    # install base fixup handler
    $dispatch->{editor}{cb_base_checksum} =
	sub { my $path = shift;
	      my $node_res = $resource;
	      $node_res =~ s/:(.*):(\d+)$/:$1$path:$2/;
	      $hold_close->{$call->[2]} = 1;
	      send_cmd ($sock, "fetch $node_res\n", sub { fixup_text ($dispatch, $sock, $path, $call) });
	      return undef;
	  }
	    if $call->[1] eq 'apply_textdelta';

    $dispatch->emit ($call);

    $closed = 1
	if $call->[1] eq 'close_edit';
    finalize ($dispatch);
}

&main;
